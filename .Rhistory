axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
ggplot2labsx = "",
ggplot2labsx = ""
ggplot2labsy = "Marginal Effect"
ggplot2axistext = 1.5
ggplot2axistitle = 2
ggplot2legendtext = 1
ggplot2legendtitle = 1.5
ggplot2legendtitlealign = 0
ggplot2plotbackgroundfill = "white"
ggplot2plotbackgroundcolour = "grey50"
ggplot2striptextx = 2
ggplot2panelbordercolour = "black"
ggplot2panelborderfill = NA
ggplot2panelborderlinewidth = 1
ggplot2legendspacingx = unit(0, "cm")
ggplot2legendbackground = ggplot2::element_blank()
ggplot2panelbackgroundfill = "white"
ggplot2panelbackgroundcolour = "grey50"
ggplot2panelgridcolour = "grey90"
ggplot2legendkey = ggplot2::element_blank()
ggsavefilename = paste0(saveloc, lubridate::today(), "_SankeyAlluvial_EMT.SoEv-EfTyp_Col-EfSz.png")
ggsaveplot = last_plot()
ggsavedevice = "png"
ggsavepath = ""
ggsavescale = 2
ggsavewidth = 10
ggsaveheight = 4
ggsaveunits = "in"
ggsavedpi = 300
ggsavelimitsize = TRUE
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
ggplot2::scale_x_discrete(guides(x =  guide_axis(angle = 90))) +
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
# ggplot2::scale_x_discrete(guides(x =  guide_axis(angle = 90))) +
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
ggplot2::scale_x_discrete(guides(x =  guide_axis(angle = 90))) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
guides(x =  guide_axis(angle = 90)) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
?guides
?guide_axis
ggplot2guideaxisangle = 0
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
ggplot2::guides(x =  ggplot2::guide_axis(angle = ggplot2guideaxisangle)) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
x <- "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2023-02-21 categorical variables issue/count_elasmo/Gaus_Best_line_isl_grp.csv"
levels <- c("west tuamotu",
"east tuamotu",
"leeward",
"windward",
"australes",
"marquesas")
if (is.character(x)) {
x <- readr::read_csv(x) # readr::read_csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2023-02-21 categorical variables issue/count_elasmo/Gaus_Best_line_isl_grp.csv")
} else {
x <- x
}
View(x)
# add check to see whether csv is categorical: first column
if (class(x[, 1][[1]]) != "character") stop("csv is not a categorical/factorial variable")
x <- x |>
# dplyr::mutate(ycentred = y - mean(y)) |> # make mean column
# The above exists already in gbm.auto L843
# Also it uses preset colname y produced by gbm.auto.
dplyr::rename(Category = tidyselect::last_col(offset = 2)) |> # no first_col option
dplyr::arrange(ycentred) # re-order the x axis for categorical variables in order from high to low value
# re-reorder by levels if present
if (!is.null(levels)) {
# check level number matches x categories
if (length(levels) != length(x$Category)) stop("number of levels doesn't match number of categories in x")
# check names match
if (!all(levels %in% x$Category)) stop(paste0("The following level names not present in categories in x: ",
levels[!levels %in% x$Category]))
x <- x |>
dplyr::mutate(Category = ordered(Category, levels = levels)) |> # recreate Category as ordered factor with levels
dplyr::arrange(Category) # arrange by labels (implicit)
}
ggplot2::ggplot(x) +
ggplot2::geom_col(aes(x = Category,
y = ycentred)) +
# rotate x axis labels
ggplot2::guides(x =  ggplot2::guide_axis(angle = ggplot2guideaxisangle)) +
# alter axis labels
ggplot2::labs(x = "",
y = "Marginal Effect") +
# change theme elements
ggplot2::theme_minimal() %+replace% ggplot2::theme(
axis.text = ggplot2::element_text(size = rel(ggplot2axistext)),
axis.title = ggplot2::element_text(size = rel(ggplot2axistitle)),
legend.text = ggplot2::element_text(size = rel(ggplot2legendtext)),
legend.title = ggplot2::element_text(size = rel(ggplot2legendtitle)),
legend.title.align = ggplot2legendtitlealign, # otherwise effect type title centre aligned for some reason
plot.background = ggplot2::element_rect(fill = ggplot2plotbackgroundfill,
colour = ggplot2plotbackgroundcolour), # white background
strip.text.x = ggplot2::element_text(size = rel(ggplot2striptextx)),
panel.border = ggplot2::element_rect(colour = ggplot2panelbordercolour,
fill = ggplot2panelborderfill,
linewidth = ggplot2panelborderlinewidth),
legend.spacing.x = ggplot2legendspacingx, # compress spacing between legend items, this is min
legend.background = ggplot2legendbackground,
panel.background = ggplot2::element_rect(fill = ggplot2panelbackgroundfill,
colour = ggplot2panelbackgroundcolour),
panel.grid = ggplot2::element_line(colour = ggplot2panelgridcolour),
legend.key = ggplot2legendkey)
factgorplotlevels <- c("west tuamotu",
"east tuamotu",
"leeward",
"windward",
"australes",
"marquesas")
View(x)
?last_plot
?unit
?aes
?rel
devtools::document()
(193129.590+194114)/2
devtools::document()
?waiver
devtools::document()
usethis::use_citation()
citation("gbm.auto")
usethis::use_github_action_check_standard()
citation("glue")
?citation
devtools::document()
devtools::check()
devtools::document()
devtools::check()
load("~/Dropbox/Galway/Analysis/R/gbm.auto/data/Juveniles.RData")
View(Juveniles)
devtools::document()
devtools::check()
?setNames
devtools::document()
devtools::check()
devtools::document()
devtools::release()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?setNames
devtools::document()
devtools::check()
devtools::release()
?layer_spatial
devtools::document()
usethis::use_package_doc
devtools::document()
# install.packages("beepr")
# install.packages("mapplots")
# install.packages("maptools")
# install.packages("rgdal")
# install.packages("rgeos")
# install.packages("raster")
# install.packages("sf")
# install.packages("shapefiles")
# install.packages("devtools")
# install.packages("gbm.auto")
library(dplyr)
library(ggpubr)
# library(mapplots)
# library(maptools)
# library(rgdal)
# library(rgeos)
# library(raster)
# library(sf)
# library(shapefiles)
# library(stats)
# library(devtools)
# install.packages("digest") #needed for devtools
library(digest)
# updates for gbm.auto
library(remotes)
remotes::install_github("SimonDedman/gbm.auto") #only do this if needs updating again!
library(gbm.auto)
RSandVSsamples <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/NarrowedVars_06072023_RSandVS.csv")
View(RSandVSsamples)
# no time, sampling dur., or depth
gbm.auto(grids = NULL,
samples = RSandVSsamples,
expvar = c(12:13,20:31),
resvar = 44,
tc = c(7,14),
lr = c(0.01, 0.005), #went back to default, and for bf as well
ZI = TRUE,
alerts = FALSE,
randomvar = TRUE,
smooth = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/")
RSandVSsamples <- RSandVSsamples[-which(is.na(RSandVSsamples[44])),]
# no time, sampling dur., or depth
gbm.auto(grids = NULL,
samples = RSandVSsamples,
expvar = c(12:13,20:31),
resvar = 44,
tc = c(7,14),
lr = c(0.01, 0.005), #went back to default, and for bf as well
ZI = TRUE,
alerts = FALSE,
randomvar = TRUE,
smooth = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/")
devtools::document()
# SD TEST HERE####
remotes::install_github("SimonDedman/gbm.auto") #only do this if needs updating again!
library(gbm.auto)
RSandVSsamples <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/NarrowedVars_07272023_RSVS.csv")
MatureRSGrid <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/MatureRSGrid.csv")
RSVScropmap <- sf::st_read(dsn = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/Map/CroppedMap/Crop_Map.shp")
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/")
# but gbm.mapsf not outputting data, whereas gbm.map IS for b&w. Why?
# Abundance_Preds_only.csv col order = lat lon pred. Is this way due to changed order in grids?
# gbm.auto L1787 : gbm.mapsf(predabund = grids[c(gridslat, gridslon, predabund)],
# gbm.mapsf function defaults:
# gbm.mapsf <- function(
#     predabund = NULL, # predicted abundance data frame produced by gbm.auto (Abundance_Preds_only.csv), with Latitude, Longitude, and Predicted Abundance columns.
#     predabundlon = 2, # Longitude column number.
#     predabundlat = 1, # Latitude column number.
#     predabundpreds = 3,
# Looks right
predabund <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/Abundance_Preds_only.csv")
gbm.auto::gbm.mapsf(predabund = predabund,
# predabundlon = 2, # Longitude column number.
# predabundlat = 1, # Latitude column number.
# predabundpreds = 3, # Predicted abundance column number.
# myLocation = NULL, # location for extents, format c(xmin, ymin, xmax, ymax).
# trim = TRUE, # remove NA & 0 values and crop to remaining date extents? Default TRUE.
# scale100 = FALSE, # scale Predicted Abundance to 100? Default FALSE.
# gmapsAPI = NULL, # enter your Google maps API here, quoted character string
# mapsource = "google", # Source for ggmap::get_map; uses Stamen as fallback if no Google Maps API present. Options: "google", "stamen", "gbm.basemap".
# googlemap = TRUE, # If pulling basemap from Google maps, this sets expansion factors since
# # Google Maps tiling zoom setup doesn't align to myLocation extents.
# maptype = "satellite",
# darkenproportion = 0, # amount to darken the basemap, 0-1.
mapzoom = 6, # google: 3 (continent) - 21 (building). stamen: 0-18
shape = RSVScropmap, # If mapsource is "gbm.basemap", enter the full path to gbm.basemaps downloaded map, typically Crop_Map.shp, including the .shp.
# expandfactor = 0, # extents expansion factor for basemap. default was 1.6
# colourscale = "viridis", # Scale fill colour scheme to use, default "viridis", other option is "gradient".
# colorscale = NULL, # Scale fill colour scheme to use, default NULL, populating this will overwrite colourscale.
# heatcolours = c("white", "yellow", "orange","red", "brown4"), # Vector of colours if gradient selected for colourscale, defaults to heatmap theme.
# colournumber = 8, # Number of colours to spread heatcolours over, if gradient selected for colourscale. Default 8.
studyspecies = "TEST",
# plottitle = paste0("Predicted abundance of ", studyspecies),
# plotsubtitle = "CPUE", # data %>% distinct(ID) %>% nrow() # 13
# legendtitle = "CPUE",
# plotcaption = paste0("gbm.auto::gbm.map, ", lubridate::today()),
# axisxlabel = "Longitude",
# axisylabel = "Latitude",
legendposition = c(0.05, 0.18),
# fontsize = 12,
# fontfamily = "Times New Roman",
# filesavename = paste0(lubridate::today(), "_", studyspecies, "_", legendtitle, ".png"),
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/gbmmapsftest"
)
if (TRUE & TRUE) print("yay")
mapsource = "google"
mapzoom = NULL
if (mapsource == "google" & mapzoom == NULL) print("yay")
mapzoom == NULL
is.null(mapzoom)
devtools::document()
# SD TEST HERE####
remotes::install_github("SimonDedman/gbm.auto") #only do this if needs updating again!
# ctrl shift F10
library(gbm.auto)
RSandVSsamples <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/NarrowedVars_07272023_RSVS.csv")
MatureRSGrid <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/MatureRSGrid.csv")
RSVScropmap <- sf::st_read(dsn = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/Map/CroppedMap/Crop_Map.shp")
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/")
# but gbm.mapsf not outputting data, whereas gbm.map IS for b&w. Why?
# Abundance_Preds_only.csv col order = lat lon pred. Is this way due to changed order in grids?
# gbm.auto L1787 : gbm.mapsf(predabund = grids[c(gridslat, gridslon, predabund)],
# gbm.mapsf function defaults:
# gbm.mapsf <- function(
#     predabund = NULL, # predicted abundance data frame produced by gbm.auto (Abundance_Preds_only.csv), with Latitude, Longitude, and Predicted Abundance columns.
#     predabundlon = 2, # Longitude column number.
#     predabundlat = 1, # Latitude column number.
#     predabundpreds = 3,
# Looks right
predabund <- read.csv("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/Abundance_Preds_only.csv")
gbm.auto::gbm.mapsf(predabund = predabund,
# predabundlon = 2, # Longitude column number.
# predabundlat = 1, # Latitude column number.
# predabundpreds = 3, # Predicted abundance column number.
# myLocation = NULL, # location for extents, format c(xmin, ymin, xmax, ymax).
# trim = TRUE, # remove NA & 0 values and crop to remaining date extents? Default TRUE.
# scale100 = FALSE, # scale Predicted Abundance to 100? Default FALSE.
# gmapsAPI = NULL, # enter your Google maps API here, quoted character string
# mapsource = "google", # Source for ggmap::get_map; uses Stamen as fallback if no Google Maps API present. Options: "google", "stamen", "gbm.basemap".
# googlemap = TRUE, # If pulling basemap from Google maps, this sets expansion factors since
# # Google Maps tiling zoom setup doesn't align to myLocation extents.
# maptype = "satellite",
# darkenproportion = 0, # amount to darken the basemap, 0-1.
# mapzoom = NULL, # google: 3 (continent) - 21 (building). stamen: 0-18
shape = RSVScropmap, # If mapsource is "gbm.basemap", enter the full path to gbm.basemaps downloaded map, typically Crop_Map.shp, including the .shp.
# expandfactor = 0, # extents expansion factor for basemap. default was 1.6
# colourscale = "viridis", # Scale fill colour scheme to use, default "viridis", other option is "gradient".
# colorscale = NULL, # Scale fill colour scheme to use, default NULL, populating this will overwrite colourscale.
# heatcolours = c("white", "yellow", "orange","red", "brown4"), # Vector of colours if gradient selected for colourscale, defaults to heatmap theme.
# colournumber = 8, # Number of colours to spread heatcolours over, if gradient selected for colourscale. Default 8.
studyspecies = "TEST",
# plottitle = paste0("Predicted abundance of ", studyspecies),
# plotsubtitle = "CPUE", # data %>% distinct(ID) %>% nrow() # 13
# legendtitle = "CPUE",
# plotcaption = paste0("gbm.auto::gbm.map, ", lubridate::today()),
# axisxlabel = "Longitude",
# axisylabel = "Latitude",
legendposition = c(0.05, 0.18),
# fontsize = 12,
# fontfamily = "Times New Roman",
# filesavename = paste0(lubridate::today(), "_", studyspecies, "_", legendtitle, ".png"),
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/gbmmapsftest"
)
gbm.auto::gbm.mapsf(predabund = predabund,
# predabundlon = 2, # Longitude column number.
# predabundlat = 1, # Latitude column number.
# predabundpreds = 3, # Predicted abundance column number.
# myLocation = NULL, # location for extents, format c(xmin, ymin, xmax, ymax).
trim = TRUE, # remove NA & 0 values and crop to remaining date extents? Default TRUE.
# scale100 = FALSE, # scale Predicted Abundance to 100? Default FALSE.
# gmapsAPI = NULL, # enter your Google maps API here, quoted character string
# mapsource = "google", # Source for ggmap::get_map; uses Stamen as fallback if no Google Maps API present. Options: "google", "stamen", "gbm.basemap".
# googlemap = TRUE, # If pulling basemap from Google maps, this sets expansion factors since
# # Google Maps tiling zoom setup doesn't align to myLocation extents.
# maptype = "satellite",
# darkenproportion = 0, # amount to darken the basemap, 0-1.
# mapzoom = NULL, # google: 3 (continent) - 21 (building). stamen: 0-18
shape = RSVScropmap, # If mapsource is "gbm.basemap", enter the full path to gbm.basemaps downloaded map, typically Crop_Map.shp, including the .shp.
# expandfactor = 0, # extents expansion factor for basemap. default was 1.6
# colourscale = "viridis", # Scale fill colour scheme to use, default "viridis", other option is "gradient".
# colorscale = NULL, # Scale fill colour scheme to use, default NULL, populating this will overwrite colourscale.
# heatcolours = c("white", "yellow", "orange","red", "brown4"), # Vector of colours if gradient selected for colourscale, defaults to heatmap theme.
# colournumber = 8, # Number of colours to spread heatcolours over, if gradient selected for colourscale. Default 8.
studyspecies = "TEST",
# plottitle = paste0("Predicted abundance of ", studyspecies),
# plotsubtitle = "CPUE", # data %>% distinct(ID) %>% nrow() # 13
# legendtitle = "CPUE",
# plotcaption = paste0("gbm.auto::gbm.map, ", lubridate::today()),
# axisxlabel = "Longitude",
# axisylabel = "Latitude",
legendposition = c(0.05, 0.18),
# fontsize = 12,
# fontfamily = "Times New Roman",
# filesavename = paste0(lubridate::today(), "_", studyspecies, "_", legendtitle, ".png"),
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/gbmmapsftest"
)
gbm.auto::gbm.mapsf(predabund = predabund,
# predabundlon = 2, # Longitude column number.
# predabundlat = 1, # Latitude column number.
# predabundpreds = 3, # Predicted abundance column number.
# myLocation = NULL, # location for extents, format c(xmin, ymin, xmax, ymax).
trim = TRUE, # remove NA & 0 values and crop to remaining date extents? Default TRUE.
trimfivepct = TRUE,
# scale100 = FALSE, # scale Predicted Abundance to 100? Default FALSE.
# gmapsAPI = NULL, # enter your Google maps API here, quoted character string
# mapsource = "google", # Source for ggmap::get_map; uses Stamen as fallback if no Google Maps API present. Options: "google", "stamen", "gbm.basemap".
# googlemap = TRUE, # If pulling basemap from Google maps, this sets expansion factors since
# # Google Maps tiling zoom setup doesn't align to myLocation extents.
# maptype = "satellite",
# darkenproportion = 0, # amount to darken the basemap, 0-1.
# mapzoom = NULL, # google: 3 (continent) - 21 (building). stamen: 0-18
shape = RSVScropmap, # If mapsource is "gbm.basemap", enter the full path to gbm.basemaps downloaded map, typically Crop_Map.shp, including the .shp.
# expandfactor = 0, # extents expansion factor for basemap. default was 1.6
# colourscale = "viridis", # Scale fill colour scheme to use, default "viridis", other option is "gradient".
# colorscale = NULL, # Scale fill colour scheme to use, default NULL, populating this will overwrite colourscale.
# heatcolours = c("white", "yellow", "orange","red", "brown4"), # Vector of colours if gradient selected for colourscale, defaults to heatmap theme.
# colournumber = 8, # Number of colours to spread heatcolours over, if gradient selected for colourscale. Default 8.
studyspecies = "TEST",
# plottitle = paste0("Predicted abundance of ", studyspecies),
# plotsubtitle = "CPUE", # data %>% distinct(ID) %>% nrow() # 13
# legendtitle = "CPUE",
# plotcaption = paste0("gbm.auto::gbm.map, ", lubridate::today()),
# axisxlabel = "Longitude",
# axisylabel = "Latitude",
legendposition = c(0.05, 0.18),
# fontsize = 12,
# fontfamily = "Times New Roman",
# filesavename = paste0(lubridate::today(), "_", studyspecies, "_", legendtitle, ".png"),
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-12-06 Cat Wells/CPUESpawnVS/gbmmapsftest"
)
devtools::document()
