par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = dbase[,loncolno], y = dbase[,latcolno],
z = dbase[,ncol(dbase)], mapmain = "Per Species Closed Area: ",
species = maploopnames[o],
heatcolours = grey.colors(8, start = 0.7, end = 0),
colournumber = length(goodcols) + 1,
shape = shape, mapback = "white",
legendtitle = paste0(badpct2, "% E closed"),
byx = byx, byy = byy, breaks = c(0,0:length(goodcols)))
dev.off()
} # close BnW
if (alerts) beep(2) # alert user
} # close "for (o in 1:length(maploopnames)"
} # close "if ("close" %in% plotthis)" end o loop through combination, goodcols & badcols
length(maploopnames)
maploopnames
####Start Species Loop 2####
for (j in 1:length(goodcols)) {  # j loop through gooddata (species) columns
n <- nrow(dbase) # set current row at start @ final row for HRMSY subloop: resets value for next species.
####HRMSY limit map####
# min area for HRMSY, starting with best fish cells
# Sort by bothdata descending then map that then overlay 15% biomass by highest bothdata
CPUEMSY <- (sum(dbase[,goodcols[j]]) * HRMSY[j]) # HRMSY% * total biomass for J'th species = biomass to protect i.e. 'sum-to threshold'
dbase <- eval(parse(text = maploopcodes[o])) #sort according to O'th maploopcode
n <- which.min((cumsum(dbase[nrow(dbase):1,goodcols[j]]) - CPUEMSY) ^ 2)
# cumsum from end (n) upwards towards 1 of CPUE until the row X
# where end:X = CPUEMSY i.e. 'open' cells; close rest i.e. n-X
assign(paste0("sort",maploopnames[o],"_",names(dbase)[goodcols[j]]),rep(0,nrow(dbase))) # create a vector of zeroes called sort[j name]
dbase <- cbind(dbase,get(paste0("sort",maploopnames[o],"_",names(dbase)[goodcols[j]]))) # bind it to dbase
colnames(dbase)[ncol(dbase)] <- paste0("sort",maploopnames[o],"_",names(dbase)[goodcols[j]]) # reinstate its name (lost because bound with get())
dbase[1:n + 1,ncol(dbase)] <- rep(1,n) # populate first n+1 rows with 1 [k:n]
badcut <- sum(dbase[1:n + 1,badcols]) # sum badcols values (i.e. total badcol value in closed area)
badall <- sum(dbase[,badcols])    # total badcols values
badpct <- round((badcut/badall)*100,1) # percent of badcols values in closed area
# this counts UP from the WORST row (last) until reaching HRMSY% (e.g. 8%) then closes the inverse
# This is massively quicker than counting DOWN from the best row to 1-HRMSY, e.g. counting through 92% of the data
# INDIVIDUAL MAPS: Map bothdata. Then Overlay map onto bothdata map: ncol=1 zeroes=TRUE. Heatcol="black".
png(filename = paste0("./ClosedValueMap_",maploopnames[o],"_",goodname[j],".png"), # map species j's bothdata with black closed areas overlaid
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
# run gbm.map function's internal code. Set parameters
x = dbase[,loncolno] #vector of longitudes, from make.grid in mapplots
y = dbase[,latcolno] #vector of latitudes, from make.grid in mapplots; grids[,gridslat]
z = dbase[,bothdatarange[j]] # scaled & weighted (bothdata) *m
heatcolours = c("red", "lightyellow","blue")
colournumber = 8   #number of colours to spread heatcol over, default:8
shape = shape   #basemap shape to draw, from draw.shape in mapplots
landcol = "grey80" #colour for 'null' (land) area of map, from draw.shape in mapplots
mapback = "lightblue" # basemap background (sea) colour
legendloc = "bottomright" #location on map of legend box, from legend.grid in mapplots
legendtitle = "0 - 2" #the metric of abundance, e.g. CPUE for fisheries, from legend.grid in mapplots
lejback = "white"  #backgroud colour of legend, from legend.grid in mapplots
zero = TRUE # allow 0 category in breaks.grid & thus legend?
quantile = 1 # set max breakpoint; lower this to cutoff outliers
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
if (!exists("byx")) {    # if users hasn't entered byx or byy values, generate them from the data
bydist <- rep(NA,length(x))   # work out cell size for uniform square gridded data: Create blank vector for grid length calcs
cells <- data.frame(LONGITUDE = x, bydist = bydist, stringsAsFactors = FALSE)   # and attach it to grids
cells[2:(length(x) - 1),"bydist"] <- ifelse(round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1],digits = 5) ==
round(cells[3:length(x),1] - cells[2:(length(x) - 1),1], digits = 5),round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1], digits = 5), NA)
byx <- mean(cells$bydist, na.rm = TRUE)  # Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
byy <- byx
} # close if (!exists("byx"))
# Plot first map: same as bothdata
grd <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y),fun = mean) #create gridded data. fun defaults to sum which is bad
heatcol = colorRampPalette(heatcolours)(colournumber) #create heatcol from component parts
breaks <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol))  #if breaks specified, do nothing (it'll be used later). Else generate it.
if (zero) {heatcol = c("#00000000", colorRampPalette(heatcol)(length(heatcol) - 1))} #if zero=TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(maploopnames[o], "-Sorted Closed Area: ", goodname[j]), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.grid(grd, breaks, col = heatcol) # plot grd data w/ breaks for colour breakpoints
# Plot second map: closed area overlay only
x = dbase[,loncolno] #set parameters for closed area map
y = dbase[,latcolno]
z = dbase[,ncol(dbase)] #last column, cbound @ L187, sort column, zeroes populated with 1s.
heatcolours2 = c("black","black")
colournumber2 = 2
grd2 <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = mean) #create gridded data. fun defaults to sum which is bad
heatcol2 = colorRampPalette(heatcolours2)(colournumber2) #create heatcol from component parts
breaks2 <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol2))  #if breaks specified, do nothing (it'll be used later). Else generate it.
if (zero) {heatcol2 = c("#00000000", colorRampPalette(heatcol2)(length(heatcol2) - 1))} #if zero=TRUE add alpha as 1st colour (1st 2 breakpoints)
draw.grid(grd2, breaks2, col = heatcol2) # plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = paste0(badpct, "% E closed"), col = heatcol)
dev.off()
# create csvs for closed area comparisons
ca_x <- dbase[,loncolno]
ca_y <- dbase[,latcolno]
ca_z <- dbase[,ncol(dbase)]
ca_df <- data.frame(lon = ca_x, lat = ca_y, closed = ca_z)
write.csv(ca_df, row.names = FALSE, file = paste0("./ClosedArea_", maploopnames[o], "_", goodname[j], ".csv"))
if (BnW) {
png(filename = paste0("./ClosedValueMap_",maploopnames[o],"_",goodname[j],"_BnW.png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
x = dbase[,loncolno]
y = dbase[,latcolno]
z = dbase[,bothdatarange[j]] # scaled & weighted (bothdata) *m
heatcolours = grey.colors(3, start = 1, end = 0)
colournumber = 8
shape = shape
landcol = grey.colors(1, start = 0.8, end = 0.8)
mapback = "white"
legendloc = "bottomright"
legendtitle = "0 - 2"
lejback = "white"
zero = TRUE
quantile = 1
if (!exists("byx")) {    # if users hasn't entered byx or byy values, generate them from the data
bydist <- rep(NA, length(x))   # work out cell size for uniform square gridded data: Create blank vector for grid length calcs
cells <- data.frame(LONGITUDE = x, bydist = bydist, stringsAsFactors = FALSE)   # and attach it to grids
cells[2:(length(x) - 1), "bydist"] <- ifelse(round(cells[2:(length(x) - 1), 1] - cells[1:(length(x) - 2), 1], digits = 5) ==
round(cells[3:length(x),1] - cells[2:(length(x) - 1), 1], digits = 5), round(cells[2:(length(x) - 1), 1] - cells[1:(length(x) - 2), 1], digits = 5), NA)
byx <- mean(cells$bydist, na.rm = TRUE)  # Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
byy <- byx
} # close if (!exists("byx"))
# Plot first map: same as bothdata
grd <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = mean) #create gridded data. fun defaults to sum which is bad
heatcol = colorRampPalette(heatcolours)(colournumber) #create heatcol from component parts
breaks <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol))  #if breaks specified, do nothing (it'll be used later). Else generate it.
if (zero) {heatcol = c("#00000000", colorRampPalette(heatcol)(length(heatcol) - 1))} #if zero=TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(maploopnames[o], "-Sorted Closed Area: ", goodname[j]), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.grid(grd, breaks, col = heatcol)
x = dbase[,loncolno]
y = dbase[,latcolno]
z = dbase[,ncol(dbase)]
heatcolours2 = c("black","black")
colournumber2 = 2
grd2 <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = mean)
heatcol2 = colorRampPalette(heatcolours2)(colournumber2)
breaks2 <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol2))
if (zero) {heatcol2 = c("#00000000",colorRampPalette(heatcol2)(length(heatcol2) - 1))}
draw.grid(grd2, breaks2, col = heatcol2)
draw.shape(shape = shape, col = landcol)
legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = paste0(badpct, "% E closed"), col = heatcol)
dev.off()
} # close BnW
if (alerts) beep(2) # alert user
} # end of 2nd FOR loop j (species)
n
MPAgrow2[,1]
names(dbase)
CPUEMSY
"sort",maploopnames[o],"_",names(dbase)[goodcols[j]]
paste0("sort",maploopnames[o],"_",names(dbase)[goodcols[j]])
rep(0,nrow(dbase))
paste0("SpeciesGrow_", maploopnames[o])
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
setwd("/home/simon/Desktop/gbmauto/")
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
# maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
maploops = c("Combo","Biomass","Effort")
maploopnames <- c("Combo","Biomass","Effort","Conservation")
which(maploopnames == maploops)
which(maploopnames %in% maploops)
maploopnames
maploopnames[loopindex]
loopindex <- which(maploopnames %in% maploops)
maploopnames[loopindex]
maploopcodes[loopindex]
# 1: max to min bothdata value for that species: highest cpue lowest e combo
# 2: max to min gooddata value for that species, i.e. highest biomass.
# 3: min to max baddata value (universal) THEN max to min gooddata value for that species, i.e. lowest effort THEN highest biomass
# 4: max to min conserve value (universal), i.e. max conservation value (all species)
maploopcodes <- c("dbase[order(-dbase[,bothdatarange[1]-1+j]),]","dbase[order(-dbase[,goodcols[j]]),]","dbase[order(dbase[,badcols],-dbase[,goodcols[j]]),]","dbase[order(-dbase[,conservecol]),]")
# set parameters for the sorting loops
maploopnames <- c("Combo","Biomass","Effort","Conservation")
# 1: max to min bothdata value for that species: highest cpue lowest e combo
# 2: max to min gooddata value for that species, i.e. highest biomass.
# 3: min to max baddata value (universal) THEN max to min gooddata value for that species, i.e. lowest effort THEN highest biomass
# 4: max to min conserve value (universal), i.e. max conservation value (all species)
maploopcodes <- c("dbase[order(-dbase[,bothdatarange[1]-1+j]),]","dbase[order(-dbase[,goodcols[j]]),]","dbase[order(dbase[,badcols],-dbase[,goodcols[j]]),]","dbase[order(-dbase[,conservecol]),]")
loopindex <- which(maploopnames %in% maploops) # which loops to run? set by user
maploopnames <- maploopnames[loopindex] # update names for only those loops
maploopcodes <- maploopcodes[loopindex] # update codes for only those loops
length(maploopnames)
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
dbase <- read.csv("Abundance_Preds_All.csv")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
# maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
o
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
# maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
gbm.valuemap
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
gbm.valuemap
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
gbm.valuemap
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
# maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Per Species Closed Area Map ",
o, " of ", length(goodcols), " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
text = maploopcodes[o]
eval(parse(text = maploopcodes[o]))
"Conservation" %in% maploops & conservecol == NULL
"Conservation" %in% maploops
conservecol == NULL
is.null(conservecol)
"Conservation" %in% maploops & is.null(conservecol)
maploopnames <- c("Combo","Biomass","Effort","Conservation")
goodcols = 47
length(goodcols)
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
maploopcodes <- c("Combo","Biomass","Effort","Conservation")
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
goodcols <- c(1,2)
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
counterA <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
goodcols <- c(1)
counterA <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
counterA <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Cumulative Closed Area Map ", counterA - 1," of ",length(goodcols)*length(maploopcodes)," XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
goodcols <- c(1,2)
counterA <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Cumulative Closed Area Map ", counterA - 1," of ",length(goodcols)*length(maploopcodes)," XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
counterA <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Cumulative Closed Area Map ", counterA - 1," of ", length(maploopcodes)," XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
goodcols <- c(1,2)
counterA <- 1
counterB <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Cumulative Closed Area Map ", counterB ," of ", length(maploopcodes)," XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
}
counterA <- 1
counterB <- 1
for (o in 1:length(maploopnames)) { # start o loop through maploops
j <- 1 # set / reset J so it restarts the loops at 1 rather than max(length(goodcols))
####Start Species Loop 2####
for (j in 1:length(goodcols)) {
# print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ",((o - 1)*length(maploopcodes)) + j," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Overlay Map ", counterA," of ",length(goodcols)*length(maploopcodes),"    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterA <- counterA + 1
}
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Cumulative Closed Area Map ", counterB ," of ", length(maploopcodes)," XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
counterB <- counterB + 1
}
length(maploopnames)
library(devtools)
document()
build()
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
# valuemap
setwd("/home/simon/Desktop/gbmauto/Cuckoo/")
dbase <- read.csv("Abundance_Preds_All.csv")
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
# maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
gbm.valuemap(dbase = dbase,  # data.frame to load. Expects Lon, Lat & data columns: predicted
# abundances, fishing effort etc. E.g.: Abundance_Preds_All.csv from gbm.auto
loncolno = 1, # column number in dbase which has longitudes
latcolno = 2, # column number in dbase which has latitudes
goodcols = 47,  # which column numbers are abundances (where higher = better)? List
# them in order of highest conservation importance first e.g. c(3,1,2,4)
badcols = 43,  # which col no.s are 'negative' e.g. fishing (where higher = worse)?
conservecol = NULL, # conservation column, from gbm.cons
plotthis = c("good","bad","both","close"), #to plot? delete any,or all w/ NULL
# maploops = c("Combo","Biomass","Effort","Conservation"), # sort loops to run
maploops = c("Combo","Biomass","Effort"), # sort loops to run
savethis = TRUE, # export all data as csv?
HRMSY = 0.15, # maximum % of each goodcols stock which can be removed yearly,
# as decimal (0.15 = 15%). Must protect remainder: 1-HRMSY.
# Single number or vector. If vector, Same order as goodcols
goodweight = NULL,  # single/vector weighting multiple(s) for goodcols array
badweight = NULL,  # ditto for badcols array
m = 1, # multiplication factor for Bpa units. 1000 to convert tonnes to kilos,
# 0.001 kilos to tonnes. Assumedly the same for all goodcols.
alerts = TRUE,  # play sounds to mark progress steps
BnW = FALSE,  # also produce greyscale images for print publications
shape = coast, #  set coastline shapefile, else uses British Isles. Generate your own with gbm.basemap
pngtype = "cairo-png") # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.utils.R')
document()
library(devtools)
document()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.utils.R')
document()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/roc.R')
document()
library(devtools)
document()
build()
check()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.rsb.R')
check()
devtools::run_examples()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
devtools::run_examples()
check()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
check()
library(devtools)
check()
?globalVariables
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
check()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
document())
document()
