#' Automated Boosted Regression Tree modelling and mapping suite
#'
#' Automates delta log normal boosted regression trees abundance prediction.
#' Loops through all permutations of parameters provided (learning
#' rate, tree complexity, bag fraction), chooses the best, then simplifies it.
#' Generates line, dot and bar plots, and outputs these and the predictions
#' and a report of all variables used, statistics for tests, variable
#' interactions, predictors used and dropped, etc.. If selected, generates
#' predicted abundance maps, and Unrepresentativeness surfaces.
#'
#' @param grids Explantory data to predict to. Import with (e.g.) read.csv and
#' specify object name. Defaults to NULL (won't predict to grids)
#' @param samples Explanatory and response variables to predict from. Keep col
#' names short, no odd characters, starting numerals or terminal periods. Spaces
#'  may be converted to periods in directory names, underscores won't. Can be a
#'  subset
#' @param expvar List of column numbers of explanatory variables in 'samples',
#' expected e.g. c(1,35,67,etc.). No default
#' @param resvar Column number(s) of response variable (e.g. CPUE) in samples.
#' e.g. 12 or c(4,5,6). No default. Column name should be species name
#' @param tc Permutations of tree complexity allowed, can be vector with
#' the largest sized number no larger than the number of explanatory variables
#' e.g. c(2,7), or a list of 2 single numbers or vectors, the first to be passed
#' to the binary BRT, the second to the Gaussian, e.g. tc = list(c(2,6), 2) or
#' list(6, c(2,6))
#' @param lr Permutations of learning rate allowed. Can be a vector or a list of
#'  2 single numbers or vectors, the first to be passed to the binary BRT, the
#'  second to the Gaussian, e.g. lr = list(c(0.01,0.02),0.0001) or
#'  list(0.01,c(0.001, 0.0005))
#' @param bf Permutations of bag fraction allowed, can be single number, vector
#' or list, per tc and lr
#' @param ZI are data zero-inflated? TRUE FALSE "CHECK". TRUE: delta BRT,
#' log-normalised Gaus, reverse log-norm and bias corrected. FALSE: do Gaussian
#' only, no log-normalisation. CHECK: Tests data for you. Default is TRUE.
#' @param simp Try simplfying best BRTs?
#' @param gridslat Column number for latitude in 'grids'
#' @param gridslon Column number for longitude in 'grids'
#' @param cols Barplot colour vector. Assignment in order of explanatory
#' variables. Default 1*white: white bars black borders. '1*' repeats
#' @param linesfiles Save individual line plots' data as csv's?
#' @param smooth Apply a smoother to the line plots? Default FALSE
#' @param savegbm Save gbm objects and make available in environment after
#' running? Open with load("Bin_Best_Model")
#' @param varint Calculate variable interactions? Default:TRUE, FALSE for error
#' "contrasts can be applied only to factors with 2 or more levels"
#' @param map Save abundance map png files?
#' @param shape Set coast shapefile, else bounds calculated by gbm.map which
#' then calls gbm.basemap to download and autogenerate the base map.
#' @param RSB Run Unrepresentativeness surface builder?
#' @param BnW Repeat maps in black and white e.g. for print journals
#' @param alerts Play sounds to mark progress steps
#' @param pngtype Filetype for png files, alternatively try "quartz"
#' @param gaus Do Gaussian runs as well as Bin? Default TRUE.
#' @param ... Optional arguments for legend in legend.grid in gbm.map, and
#' gbm.step (dismo)
#'
#' @return Line, dot and bar plots, a report of all variables used, statistics
#' for tests, variable interactions, predictors used and dropped, etc. If
#' selected generates predicted abundance maps, and Unrepresentativeness surface
#'
#' @details Errors and their origins:
#'
#' 1. Error in FUN(X[[i]], ...) : only defined on a data frame with all numeric variables
#' > Explanatory variables are expected to be numeric
#'
#' 2. At bf=0.5, if nrows <= 42 gbm.step will crash
#' > Use gbm.bfcheck to determine optimal viable bf size
#'
#' 3. Maps/plots dont work/output
#' > If on a Mac, try changing pngtype to "quartz"
#'
#' 4. Error in while (delta.deviance > tolerance.test AMPERSAND n.fitted < max.trees)  :
#'  missing value where TRUE/FALSE needed
#' > Data are expected to contain zeroes (lots of them in zero-inflated cases),
#' have you already filtered them out?
#'
#' 5. Error in round(gbm.object$cv.statistics$deviance.mean, 4) : non-numeric
#' argument to mathematical function
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#'
#' 6. Error in if (n.trees > x$n.trees) { : argument is of length zero}
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#'
#' 7. Error in gbm.fit(x, y, offset = offset, distribution = distribution, w = w)
#' The dataset size is too small or subsampling rate is too large:
#' nTrain*bag.fraction <= n.minobsinnode
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#' It may be that you don't have enough positive samples to run BRT modelling
#' Run gbm.bfcheck to check recommended minimum BF size
#'
#' 8. Warning message: In cor(y_i, u_i) : the standard deviation is zero
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#' It may be that you don't have enough positive samples to run BRT modelling
#' Run gbm.bfcheck to check recommended minimum BF size
#'
#' 9. Anomalous values can obfuscate clarity in line plots e.g. salinity range
#' 32:35 degrees but dataset has errant 0 value: plot axis 0:35, 99.99% data
#' in the tiny bit at the right. Clean your data well beforehand.
#'
#' @examples gbm.auto(expvar = c(4:8, 10), resvar = 11, grids = mygrids,
#' tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
#'
#' @author Simon Dedman, \email{simondedman@@gmail.com}
#'
#' @export
#' @import mapplots
#' @importFrom beepr beep
#' @importFrom labeling extended
#' @importFrom dismo gbm.interactions
#' @importFrom dismo gbm.plot.fits
#' @importFrom dismo gbm.plot
#' @importFrom dismo gbm.simplify
#' @importFrom dismo gbm.step
#' @importFrom gbm plot.gbm
#'
gbm.auto <- function(
  grids = NULL,         # explantory data to predict to. Import with (e.g.)
  # read.csv and specify object name. Defaults to NULL (won't predict to grids)
  samples,  # explanatory and response variables to predict from.
  # Keep col names short, no odd characters, starting numerals or terminal periods
  # Spaces may be converted to periods in directory names, underscores won't.
  # Can be a subset
  expvar,               # list of column numbers of explanatory variables in
  # 'samples', expected e.g. c(1,35,67,etc.). No default
  resvar,               # column number(s) of response variable (e.g. CPUE) in
  # samples, e.g. 12 or c(4,5,6). No default. Column name should be species name
  tc = c(2),            # permutations of tree complexity allowed, can be a
  # vector with the largest sized number no larger than the number of
  # explanatory variables e.g. c(2,7), or a list of 2 single numbers or vectors,
  # the first to be passed to the binary BRT, the second to the Gaussian, e.g.
  # tc = list(c(2,6), 2) or list(6, c(2,6))
  lr = c(0.01,0.005),   # permutations of learning rate allowed. Can be a
  # vector or a list of 2 single numbers or vectors, the first to be passed to
  # the binary BRT, the second to the Gaussian, e.g.
  # lr = list(c(0.01,0.02),0.0001) or list(0.01,c(0.001, 0.0005))
  bf = 0.5,             # permutations of bag fraction allowed, can be single
  # number, vector or list, per tc and lr
  ZI = "CHECK",         # are data zero-inflated? TRUE/FALSE/"CHECK".
  # TRUE: delta BRT, log-normalised Gaus, reverse log-norm and bias corrected.
  # FALSE: do Gaussian only, no log-normalisation.
  # CHECK: Tests data for you. Default is TRUE.
  simp = TRUE,          # try simplfying best BRTs?
  gridslat = 2,         # column number for latitude in 'grids'
  gridslon = 1,         # column number for longitude in 'grids'
  cols = grey.colors(1,1,1), # barplot colour vector. Assignment in order of
  # explanatory variables. Default 1*white: white bars black borders. '1*' repeats
  linesfiles = TRUE,    # save individual line plots' data as csv's?
  smooth = FALSE,       # apply a smoother to the line plots? Default FALSE
  savegbm = TRUE,       # save gbm objects and make available in environment after running? Open with load("Bin_Best_Model")
  varint = TRUE,        # calculate variable interactions? Default:TRUE, FALSE
  # for error "contrasts can be applied only to factors with 2 or more levels"
  map = TRUE,           # save abundance map png files?
  shape = NULL,         # set coast shapefile, else bounds calculated by gbm.map
  # which then calls gbm.basemap to download and autogenerate the base map.
  RSB = TRUE,           # run Unrepresentativeness surface builder?
  BnW = TRUE,           # repeat maps in black and white e.g. for print journals
  alerts = TRUE,        # play sounds to mark progress steps
  pngtype = "cairo-png",# filetype for png files, alternatively try "quartz"
  gaus = TRUE,          # do Gaussian runs as well as Bin? Default TRUE.
  ...)                  # optional arguments for gbm.map and gbm.step
{
  # Generalised Boosting Model / Boosted Regression Tree process chain automater.
  # Simon Dedman, 2012-6 simondedman@gmail.com github.com/SimonDedman/gbm.auto

  # Function to automate the many steps required to use boosted regression trees
  # to predict abundances in a delta process, i.e. binary (0/1) proportion
  # prediction coupled with presence-only abundance prediction to give total
  # prediction. Loops through all permutations of parameters provided (learning
  # rate, tree complexity, bag fraction), chooses the best, then tries to simplify
  # that. Generates line, dot and bar plots, and outputs these and the predictions
  # and a report of all variables used, statistics for tests, variable
  # interactions, predictors used and dropped, etc.. If selected, generates
  # predicted abundance maps, and Unrepresentativeness surfaces.
  #
  # Underlying functions are from packages gbm and dismo, functions from Elith
  # et al. 2008 (bundled as gbm.utils.R), mapplots, and my own functions gbm.map,
  # gbm.rsb, gbm.valuemap, gbm.cons, gbm.basemap

  ####1. Check packages, start loop####
  if (!require(gbm)) {stop("you need to install the gbm package to run this function")}
  if (!require(dismo)) {stop("you need to install the dismo package to run this function")}
  if (alerts) if (!require(beepr)) {stop("you need to install the beepr package to run this function")}
  if (!require(labeling)) {stop("you need to install the labeling package to run this function")}
  if (map) if (!require(mapplots)) {stop("you need to install the mapplots package to run this function")}
  if (map) if (!exists("gbm.map")) {stop("you need to install the gbm.map function to run this function")}
  if (RSB) if (!exists("gbm.rsb")) {stop("you need to install the gbm.rsb function to run this function")}
  if (RSB) if (!exists("gbm.map")) {stop("you need to install the gbm.map function to run this function")}
  if (!is.null(grids)) if (!exists("gbm.predict.grids")) {stop("you need to install the gbm.predict.grids function from gbm.utils.R to run this function")}
  if (!exists("roc")) {stop("you need to install the roc function from gbm.utils.R to run this function")}
  if (!exists("calibration")) {stop("you need to install the calibration function from gbm.utils.R to run this function")}
  require(gbm)
  require(dismo)
  if (alerts) require(beepr)
  require(labeling)

  # create basemap using gbm.basemap & these bounds, else basemap will be called for every map
  if (!is.null(grids)) if (map) { # create basemap grids not null, map requested, basemap not provided
    if (is.null(shape)) {
      if (!exists("gbm.basemap")) {stop("you need to install gbm.basemap to run this function")}
      bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
      #create standard bounds from data, and extra bounds for map aesthetic
      xmid <- mean(bounds[1:2])
      ymid <- mean(bounds[3:4])
      xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
      xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
      yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
      yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
      extrabounds <- c(xextramin, xextramax, yextramin, yextramax)
      shape <- gbm.basemap(bounds = extrabounds)
    }}

  if (alerts) options(error = function() {beep(9)})  # give warning noise if it fails

  expvarnames <- names(samples[expvar]) # list of explanatory variable names
  expvarcols <- cbind(cols[1:length(expvarnames)],expvarnames) # assign explanatory variables to colours

  if (is.list(tc)) { # if lists entered for tc lr or bf, split them to bin and gaus
    if (length(tc) > 2) {stop("Only 2 tc list items allowed: 1 bin 1 Gaus")}
    tcgaus <- tc[[2]]
    tc <- tc[[1]]
  } else {tcgaus <- tc} # else make the gaus object the same as the bin

  if (is.list(lr)) {
    if (length(lr) > 2) {stop("Only 2 lr list items allowed: 1 bin 1 Gaus")}
    lrgaus <- lr[[2]]
    lr <- lr[[1]]
  } else {lrgaus <- lr}

  if (is.list(bf)) {
    if (length(bf) > 2) {stop("Only 2 bf list items allowed: 1 bin 1 Gaus")}
    bfgaus <- bf[[2]]
    bf <- bf[[1]]
  } else {bfgaus <- bf}

  for (i in resvar) { # loop everything for each response variable (e.g. species)
    m = 1 # Gaus only loop counter to allow best gaus BRT choice
    n = 1   # Print counter for all loops of BRT combos & best bin BRT choice
    if (!is.null(grids)) if (!all(expvarnames %in% names(grids))) {stop("Not all expvar column names found as column names in grids")}

    ####2. ZI check & log####
    # if user has asked code to check for ZI, check it & set new ZI status
    if (ZI == "CHECK") if (sum(samples[,i] == 0,na.rm = TRUE)/length(samples[,i]) >= 0.5) ZI = TRUE else ZI = FALSE

    # ensure resvar has zeroes (expects mix of successful & unsuccessful samples)
    if (min(samples[i]) > 0) print("No zeroes in response variable. Method expects unsuccessful, as well as successful, samples")

    # create binary (0/1) response variable, for bernoulli BRTs
    samples$brv <- ifelse(samples[i] > 0, 1, 0)
    brvcol <- which(colnames(samples) == "brv") # brv column number for BRT

    # create logged response variable, for gaussian BRTs when data are zero-inflated (otherwise just use resvar directly)
    logem <- log(samples[,i]) # logs resvar i.e. containing zeroes
    dont  <- samples[,i]
    if (ZI) {samples$grv <- logem} else {samples$grv <- dont}
    grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
    grv_yes <- subset(samples, grv >= 0) # nonzero subset for gaussian BRTs
    # actually not nonzero but 'not -Inf' since zeroes logged to "-Inf"
    # Change this to grv_yes <- samples if using a hurdle model including zeroes
    # need to keep it as log1p in that case?

    ####3. Begin Report####
    #reportcolno = (3 + (5*(length(tc)*length(lr)*length(bf))) + 14)
    if (ZI) {
      reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 14
    } else {
      reportcolno = 3 + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 7
    }
    if (!gaus) reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + 7
    # calculate number of columns for report:
      # 3: expvar names, resvar name, ZI state
      # 14: best bin brt, best gaus brt,
      # Bin_BRT_simp predictors kept (ordered), Bin_BRT_simp predictors dropped,
      # Gaus_BRT_simp predictors kept (ordered),Gaus_BRT_simp predictors dropped,
      # Simplified Binary BRT stats, Simplified Gaussian BRT stats,
      # Best Binary BRT variables, Relative Influence (Bin),
      # Best Gaussian BRT variables, Relative Influence (Gaus),
      # Biggest Interactions (Bin), Biggest Interactions (Gaus)
      # + 5 elements for each loop: parameter combo n (tc lr & bf values),
      # Bin BRT n stats, Bin BRT n name
      # Gaus BRT n stats, Gaus BRT n name
    Report <- data.frame(matrix(NA, nrow = (max(6,length(expvar))), ncol = (reportcolno)))
    # build blank df, rows=biggest of 6 (max static row number of stats) or n of exp. vars
    colnames(Report) <- c("Explanatory Variables","Response Variables","Zero Inflated?") # populate static colnames 1:3
    # name bin columns if ZI
    if (!gaus) {colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Binary BRT",
                                                                  "Bin_BRT_simp predictors kept (ordered)",
                                                                  "Bin_BRT_simp predictors dropped",
                                                                  "Simplified Binary BRT stats",
                                                                  "Best Binary BRT variables",
                                                                  "Relative Influence (Bin)",
                                                                  "Biggest Interactions (Bin)")
    } else {if (ZI) {colnames(Report)[(reportcolno - 13):(reportcolno - 7)] <- c("Best Binary BRT",
                                                                "Bin_BRT_simp predictors kept (ordered)",
                                                                "Bin_BRT_simp predictors dropped",
                                                                "Simplified Binary BRT stats",
                                                                "Best Binary BRT variables",
                                                                "Relative Influence (Bin)",
                                                                "Biggest Interactions (Bin)")}
    colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Gaussian BRT",
                                                         "Gaus_BRT_simp predictors kept (ordered)",
                                                         "Gaus_BRT_simp predictors dropped",
                                                         "Simplified Gaussian BRT stats",
                                                         "Best Gaussian BRT variables",
                                                         "Relative Influence (Gaus)",
                                                         "Biggest Interactions (Gaus)")}
    # populate the final 14 column names
    Report[1:length(expvar),1] <- names(samples[expvar]) # put expvar names in first column
    Report[1,2] <- names(samples[i]) # put resvar in col 2
    Report[1,3] <- ZI # ZI in col 3

    Bin_Best_Score <- 0 # create blanks for best results to use in loops
    Bin_Best_Model <- 0
    Gaus_Best_Score <- 0
    Gaus_Best_Model <- 0

    # Begin bin loops
    if (ZI) {  # don't do if ZI=FALSE
      for (j in tc) {   # list permutations of tree complexity allowed
        for (k in lr) {   # list permutations of learning rate allowed
          for (l in bf) {   # list permutations of bag fraction allowed

            ####4. Binomial BRT####
            assign(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""),
                   gbm.step(data = samples,
                            gbm.x = expvar,
                            gbm.y = brvcol,
                            family = "bernoulli",
                            tree.complexity = j,
                            learning.rate = k,
                            bag.fraction = l,
                            ...)
            )

            print(paste("Done Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))

            ####5. Select best bin model####
            if (n == 1)
            {Bin_Best_Score <- get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
            Bin_Best_Model <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")
            }  else if (get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]] > Bin_Best_Score)
            {Bin_Best_Score <- get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
            Bin_Best_Model <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

            ####6. Add BRT bin stats to report####
            # don't do if ZI=FALSE. bin BRT stats
            if (ZI) {Report[1:6,(3 + n)] <- c(paste("trees: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                              paste("Training Data Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                              paste("CV Mean Deviance: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                              paste("CV Deviance SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                              paste("CV Mean Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                              paste("CV Correlation SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
            # bin BRT name
            colnames(Report)[3 + n] <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

            if (alerts) beep(2) # progress printer, right aligned
            if (gaus) {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
            } else {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}
            n <- n + 1   # Add to print counter
          } # close bf
        } # close lr
      } # close tc
    } # close ZI option, making all bin BRT objects & continuing through model selection

    # Begin Gaus loops
    if (gaus) for (j in tcgaus) {   # list permutations of tree complexity allowed
      for (k in lrgaus) {   # list permutations of learning rate allowed
        for (l in bfgaus) {   # list permutations of bag fraction allowed
          ####7. Gaussian BRT####
          assign(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""),
                 gbm.step(data = grv_yes,
                          gbm.x = expvar,
                          gbm.y = grvcol,
                          family = "gaussian",
                          tree.complexity = j,
                          learning.rate = k,
                          bag.fraction = l,
                          ...)
          )
          print(paste("Done Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))
          ####9. Select best Gaus model####
          if (m == 1)
          {Gaus_Best_Score <- get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
          Gaus_Best_Model <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")
          } else if (get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]] > Gaus_Best_Score)
          {Gaus_Best_Score <- get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
          Gaus_Best_Model <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

          if (alerts) beep(2) # progress printer, right aligned for visibility
          if (ZI) {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)),"     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
          } else {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tcgaus)*length(lrgaus)*length(bfgaus)),"     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

          ####10. Add BRT bin stats to report####
          Report[1:6,(3 + n)] <- c(paste("trees: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                   paste("Training Data Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                   paste("CV Mean Deviance: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                   paste("CV Deviance SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                   paste("CV Mean Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                   paste("CV Correlation SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
          # Gaus BRT name
          colnames(Report)[3 + n] <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")

          n <- n + 1 # Add to print/loop counter for every bin or gaus BRT loop
          m <- m + 1 # Add to loop counter for Gaus best model selection

        } # close bfgaus
      } # close lrgaus
    } # close tcgaus, making all Gaus BRT objects & continuing through model selection

    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        Closed Loops         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####11. Test simplification benefit, do so if better####
    # copy Bin/Gaus_Best_Model to Name in case not created by Simp
    Bin_Best_Name <- Bin_Best_Model
    if (gaus) Gaus_Best_Name <- Gaus_Best_Model

    # if simp TRUE & ZI=TRUE, run simplification test on best bin model
    if (simp) {if (ZI) {Bin_Best_Simp_Check <- gbm.simplify(get(Bin_Best_Model))
    # if best number of variables to remove isn't 0 (i.e. it's worth simplifying),
    # re-run best model (Bin_Best_Model, using gbm.call to get its values) with
    # just-calculated best number of variables to remove, removed. gbm.x asks which
    # number of drops has the minimum mean (lowest point on the line) & that calls
    # up the list of predictor variables with those removed, from $pred.list
      if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
      assign("Bin_Best_Simp",
               gbm.step(data = samples,
                        gbm.x = Bin_Best_Simp_Check$pred.list[[which.min(Bin_Best_Simp_Check$deviance.summary$mean)]],
                        gbm.y = get(Bin_Best_Model)$gbm.call$gbm.y,
                        tree.complexity = get(Bin_Best_Model)$gbm.call$tree.complexity,
                        learning.rate = get(Bin_Best_Model)$gbm.call$learning.rate,
                        family = get(Bin_Best_Model)$gbm.call$family,
                        bag.fraction = get(Bin_Best_Model)$gbm.call$bag.fraction))}

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Bin model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
    } # close ZI

      # Same for Gaus
      if (gaus) {Gaus_Best_Simp_Check <- gbm.simplify(get(Gaus_Best_Model))
      if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0)
        assign("Gaus_Best_Simp",
               gbm.step(data = grv_yes,
                        gbm.x = Gaus_Best_Simp_Check$pred.list[[which.min(Gaus_Best_Simp_Check$deviance.summary$mean)]],
                        gbm.y = get(Gaus_Best_Model)$gbm.call$gbm.y,
                        tree.complexity = get(Gaus_Best_Model)$gbm.call$tree.complexity,
                        learning.rate = get(Gaus_Best_Model)$gbm.call$learning.rate,
                        family = get(Gaus_Best_Model)$gbm.call$family,
                        bag.fraction = get(Gaus_Best_Model)$gbm.call$bag.fraction))

      if (alerts) beep(2)
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Gaus model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

      ## Select final best models
      if (ZI) {  # don't do if ZI=FALSE. If Bin_Best has a simplified model:
        if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0)
          # & if the simplified model has better correlation than Bin_Best itself
          if (Bin_Best_Simp$self.statistics$correlation > Bin_Best_Score[1])
            # then replace Bin_Best score/model values with those from the simplified model
          {Bin_Best_Score <- Bin_Best_Simp$self.statistics$correlation
          Bin_Best_Model <- "Bin_Best_Simp"
          Bin_Best_Name <- paste(Bin_Best_Model, "_Simp", sep = "")}} # close ZI

      # Same for Gaus:
      if (gaus) {if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0)
        if (Gaus_Best_Simp$self.statistics$correlation > Gaus_Best_Score[1])
        {Gaus_Best_Score <- Gaus_Best_Simp$self.statistics$correlation
        Gaus_Best_Model <- "Gaus_Best_Simp"
        Gaus_Best_Name <- paste(Gaus_Best_Model, "_Simp", sep = "")}}
    } # close simp optional

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Best models selected     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####12. Line plots####
    # Note that anomalous values can obfuscate clarity e.g. salinity range
    # 32:35 degrees but dataset has errant 0 value: plot axis 0:35, 99.99% data
    # in the tiny bit at the right. Clean your data well.

    dir.create(names(samples[i])) # create resvar-named directory for outputs

    # All plots on one image for Bin & Gaus
    if (ZI) {  # don't do if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Best_line.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
      gbm.plot(get(Bin_Best_Model),
               n.plots = length(get(Bin_Best_Model)$contributions$var),
               write.title = F, y.label = "Marginal Effect",
               plot.layout = c(ceiling(sqrt(length(get(Bin_Best_Model)$contributions$var))),
                               ifelse(sqrt(length(get(Bin_Best_Model)$contributions$var))
                                      - floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) < 0.5,
                                      floor(sqrt(length(get(Bin_Best_Model)$contributions$var))),
                                      floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) + 1)))
      dev.off()} # close ZI

    if (gaus) {png(filename = paste("./",names(samples[i]),"/Gaus_Best_line.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
    gbm.plot(get(Gaus_Best_Model),
             n.plots = length(get(Gaus_Best_Model)$contributions$var),
             write.title = F, y.label = "Marginal Effect",
             plot.layout = c(ceiling(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
                             ifelse(sqrt(length(get(Gaus_Best_Model)$contributions$var))
                                    - floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) < 0.5,
                                    floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
                                    floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) + 1)))
    dev.off()}

    # All plots individually, named by explanatory variable, bin & gaus
    if (ZI) {  # don't do if ZI=FALSE
      for (o in 1:length(get(Bin_Best_Model)$contributions$var)) {
        png(filename = paste("./",names(samples[i]),"/Bin_Best_line_",as.character(get(Bin_Best_Model)$gbm.call$predictor.names[o]),".png", sep = ""),
            width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
        par(mar = c(2.3,5,0.3,0.4), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(1.25,0.5,0), xpd = NA)
        gbm.plot(get(Bin_Best_Model),
                 variable.no = o, # order of variable.no =! order of get(Bin_Best_Model)$contributions$var
                 n.plots = 1,
                 smooth = smooth,
                 rug = TRUE,
                 write.title = FALSE,
                 y.label = "Marginal Effect",
                 x.label = NULL,
                 show.contrib = TRUE,
                 plot.layout = c(1, 1)) # ... for cex.axis, cex.lab etc
        mtext("Marginal Effect", side = 2, line = 4.05, las = 0)

        # bg=expvarcols[match(get(Bin_Best_Model)$contributions$var[o],expvarcols[,2]),1]) #changed margin to hide label #XPD YPD ALLOWS AXES TO EXTEND FURTHER TO ENCOMPASS ALL DATA? #colour removed
        #plotgrid <- plot.gbm(get(Bin_Best_Model), match(get(Bin_Best_Model)$contributions$var[o], get(Bin_Best_Model)$gbm.call$predictor.names), lwd = 8, return.grid = TRUE)
        #if (linesfiles) write.csv(plotgrid, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Bin_Best_line_", as.character(get(Bin_Best_Model)$contributions$var[o]), ".csv", sep = ""))
        #xx <- extended(min(plotgrid[1]), max(plotgrid[1]),7, only.loose = TRUE) # sets range & ticks
        #yy <- extended(min(plotgrid[2]), max(plotgrid[2]),7, only.loose = TRUE) # sets range & ticks
        #plot(range(xx), range(yy), t = "n", xaxt = "n", yaxt = "n", bty = "n", ylab = NA)
        #lines(plotgrid, type = "l")
        #axis(1, lwd.ticks = 8, lwd = 8, at = xx) # is providing only the thick line & downticks
        #axis(2, lwd.ticks = 8, lwd = 8, at = yy)
        #rug(quantile(samples[as.character(get(Bin_Best_Model)$contributions$var[o])], probs=seq(0,1,0.01), na.rm=TRUE), side=1, lwd=5, ticksize=0.03) #n of ticks probs seq arg 3: 0.1, 0.05, 0.01
        #rug(samples[as.character(get(Bin_Best_Model)$contributions$var[o])][,1], side = 1, lwd = 5, ticksize = 0.03) # all points rug
        dev.off() }} # close ZI option

    if (gaus) {for (p in 1:length(get(Gaus_Best_Model)$contributions$var)) {
      png(filename = paste("./",names(samples[i]),"/Gaus_Best_line_",as.character(get(Gaus_Best_Model)$gbm.call$predictor.names[p]),".png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
      par(mar = c(2.3,5,0.3,0.4), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(1.25,0.5,0), xpd = NA)
      gbm.plot(get(Gaus_Best_Model),
               variable.no = p,
               n.plots = 1,
               smooth = smooth,
               rug = TRUE,
               write.title = FALSE,
               y.label = "",
               x.label = NULL,
               show.contrib = TRUE,
               plot.layout = c(1, 1))
      mtext("Marginal Effect", side = 2, line = 4.05, las = 0)

      #plotgrid <- plot.gbm(get(Gaus_Best_Model),match(get(Gaus_Best_Model)$contributions$var[p], get(Gaus_Best_Model)$gbm.call$predictor.names), lwd = 8, return.grid = TRUE)
      #if (linesfiles) write.csv(plotgrid, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Gaus_Best_line_", as.character(get(Gaus_Best_Model)$contributions$var[p]), ".csv", sep = ""))
      #xx <- extended(min(plotgrid[1]), max(plotgrid[1]),7, only.loose = TRUE)
      #yy <- extended(min(plotgrid[2]), max(plotgrid[2]),7, only.loose = TRUE)
      #plot(range(xx),range(yy), t = "n", xaxt = "n", yaxt = "n", bty = "n", ylab = NA)
      #lines(plotgrid, type = "l")
      #axis(1, lwd.ticks = 8, lwd = 8, at = xx)
      #axis(2, lwd.ticks = 8, lwd = 8, at = yy)
      #rug(samples[as.character(get(Gaus_Best_Model)$gbm.call$predictor.names[p])][,1], side = 1, lwd = 5, ticksize = 0.03, quiet = TRUE)
      # quiet=TRUE because x axis is incorrect relative to points. Have tried only.loose=FALSE in xx line
      # also plotgridbin from bin to use bin's x axis but didn't work. Tried matching gaus & bin no joy.
      dev.off() }}

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Line plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####13. Dot plots####
    if (ZI) {  # don't do if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Best_dot.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
      gbm.plot.fits(get(Bin_Best_Model))
      dev.off()} # close ZI

    if (gaus) {png(filename = paste("./",names(samples[i]),"/Gaus_Best_dot.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
    gbm.plot.fits(get(Gaus_Best_Model))
    dev.off()}

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Dot plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####14. 3D plot TODO####
    # gbm.perspec(Bin_Best,3,2, z.range=c(0,31), theta=340, phi=35,smooth="none",border="#00000025",col="#ff003310",shade = 0.95, ltheta = 80, lphi = 50)
    # gbm.perspec(Gaus_Best,3,2, z.range=c(0,31), theta=340, phi=35,smooth="none",border="#00000025",col="#ff003310",shade = 0.95, ltheta = 80, lphi = 50)

    ####15. Bar plots of variable influence####
    if (ZI) {  # create tables. Don't do if ZI=FALSE
      Bin_Bars <- summary(get(Bin_Best_Model),
                          cBars = length(get(Bin_Best_Model)$var.names),
                          n.trees = get(Bin_Best_Model)$n.trees,
                          plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
      write.csv(Bin_Bars, file = paste("./", names(samples[i]), "/Binary BRT Variable contributions.csv", sep = ""), row.names = FALSE)} # close ZI

    if (gaus) {Gaus_Bars <- summary(get(Gaus_Best_Model),
                         cBars = length(get(Gaus_Best_Model)$var.names),
                         n.trees = get(Gaus_Best_Model)$n.trees,
                         plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
    write.csv(Gaus_Bars, file = paste("./", names(samples[i]), "/Gaussian BRT Variable contributions.csv", sep = ""), row.names = FALSE)}

    if (alerts) beep(2)# progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Bar plot csvs created    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    if (ZI) {  # produce graphics. Don't do bin if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Bars.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
          type = pngtype)
      par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.8,mgp = c(1.5,0.5,0), cex = 1.3)
      midpoints <- barplot(rev(Bin_Bars[,2]), cex.lab = 1.2, las = 1,
                           horiz = TRUE, cex.names = 0.8, xlab = "Influence %",
                           col = rev(expvarcols[match(Bin_Bars[,1],expvarcols[,2]),1]),
                           xlim = c(0,2.5 + ceiling(max(Bin_Bars[,2]))),
                           lwd = 4)
      # add lwd = 4 to barplot to increase line thickness
      text(0.1, midpoints, labels = rev(Bin_Bars[,1]), adj = 0, cex = 1.5)
      axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
      dev.off()} # close ZI

    if (gaus) {png(filename = paste("./",names(samples[i]),"/Gaus_Bars.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
        type = pngtype)
    par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.8,mgp = c(1.5,0.5,0), cex = 1.3)
    midpoints <- barplot(rev(Gaus_Bars[,2]), cex.lab = 1.2, las = 1, horiz = TRUE, cex.names = 0.8, xlab = "Influence %", col = rev(expvarcols[match(Gaus_Bars[,1],expvarcols[,2]),1]), xlim = c(0,2.5 + ceiling(max(Gaus_Bars[,2]))))
    text(0.1, midpoints, labels = rev(Gaus_Bars[,1]), adj = 0, cex = 1.5)
    axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
    dev.off()}

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Bar plots plotted      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####16. Variable interactions####
    # only do them if varint=TRUE, the default. Only do bin if ZI=TRUE
    if (ZI) if (varint) find.int_Bin <- gbm.interactions(get(Bin_Best_Model))
    if (gaus) if (varint) find.int_Gaus <- gbm.interactions(get(Gaus_Best_Model))
    if (alerts) beep(2) # progress printer, right aligned for visibility
    if (varint) {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Variable interactions done XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

    #avoid sections 16-20 if not predicting to grids
    if (!is.null(grids)) {

    ####17. Binomial predictions####
      if (ZI) {  # don't do if ZI=FALSE
        gbm.predict.grids(get(Bin_Best_Model), grids, want.grids = F, sp.name = "Bin_Preds")
        grids$Bin_Preds <- Bin_Preds} # close ZI

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Binomial predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####18. Gaussian predictions####
      if (gaus) gbm.predict.grids(get(Gaus_Best_Model), grids, want.grids = F, sp.name = "Gaus_Preds")
      if (gaus) {if (ZI) {grids$Gaus_Preds <- Gaus_Preds

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Gaussian predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####19. Backtransform logged Gaus to unlogged####
      if (gaus) grids$Gaus_Preds_Unlog <- exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)

    ####20. BIN*positive abundance = final abundance####
      grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds} else {grids$PredAbund <- Gaus_Preds} #if ZI=TRUE, unlog gaus & multiply by bin. Else just use gaus preds.
      } else grids$PredAbund <- grids$Bin_Preds # if only doing Bin, preds are just bin preds
      predabund <- which(colnames(grids) == "PredAbund") # predicted abundance column number for writecsv

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Final abundance calculated  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####21. Final saves####
      # CSV of Predicted values at each site inc predictor variables' values.
      write.csv(grids, row.names = FALSE, file = paste("./", names(samples[i]), "/Abundance_Preds_All.csv", sep = ""))
      # CSV of Predicted values at each site without predictor variables' values.
      write.csv(grids[c(gridslat,gridslon,predabund)], row.names = FALSE, file = paste("./", names(samples[i]), "/Abundance_Preds_only.csv", sep = ""))
      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Output CSVs written     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
    } #close grids option from above section 16

    if (savegbm) { # Save model objects if switched on
      if (ZI) {Bin_Best_Model_Object <- get(Bin_Best_Model)
      Bin_Best_Model <<- Bin_Best_Model_Object}
      if (gaus) {Gaus_Best_Model_Object <- get(Gaus_Best_Model)
      Gaus_Best_Model <<- Gaus_Best_Model_Object
      save(Gaus_Best_Model_Object,file = paste("./",names(samples[i]),"/Gaus_Best_Model", sep = ""))}
      if (ZI) {save(Bin_Best_Model_Object,file = paste("./",names(samples[i]),"/Bin_Best_Model", sep = ""))} #only save bin if ZI=TRUE
      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Model objects saved     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
      }

    ####22. Finalise & Write Report####
    if (ZI)
    { # only do bin bits if ZI; move 7 cols left if no gaus run
      if (gaus) {Report[1:5,(reportcolno - 13)] <- c(paste("Model combo: ", Bin_Best_Name, sep = ""),
                                          paste("Model CV score: ", Bin_Best_Score, sep = ""),
                                          paste("Training data AUC score: ", get(Bin_Best_Model)$self.statistics$discrimination, sep = ""),
                                          paste("CV AUC score: ", get(Bin_Best_Model)$cv.statistics$discrimination.mean, sep = ""),
                                          paste("CV AUC se: ", get(Bin_Best_Model)$cv.statistics$discrimination.se, sep = ""))
      } else {Report[1:5,(reportcolno - 6)] <- c(paste("Model combo: ", Bin_Best_Name, sep = ""),
                                                  paste("Model CV score: ", Bin_Best_Score, sep = ""),
                                                  paste("Training data AUC score: ", get(Bin_Best_Model)$self.statistics$discrimination, sep = ""),
                                                  paste("CV AUC score: ", get(Bin_Best_Model)$cv.statistics$discrimination.mean, sep = ""),
                                                  paste("CV AUC se: ", get(Bin_Best_Model)$cv.statistics$discrimination.se, sep = ""))}
      if (simp)
      {Report[1:dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 12)] <- as.character(subset(Bin_Best_Simp_Check$final.drops, order > 0)$preds)
        Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 11)] <-
        as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])
        if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0)
        {Report[1:6,(reportcolno - 10)] <- c(paste("trees: ", Bin_Best_Simp$n.trees, sep = ""),
                                             paste("Training Data Correlation: ", Bin_Best_Simp$self.statistics$correlation[[1]], sep = ""),
                                             paste("CV Mean Deviance: ", Bin_Best_Simp$cv.statistics$deviance.mean, sep = ""),
                                             paste("CV Deviance SE: ", Bin_Best_Simp$cv.statistics$deviance.se, sep = ""),
                                             paste("CV Mean Correlation: ", Bin_Best_Simp$cv.statistics$correlation.mean, sep = ""),
                                             paste("CV Correlation SE: ", Bin_Best_Simp$cv.statistics$correlation.se, sep = ""))
        } else {Report[1,(reportcolno - 10)] <- paste("No simplification benefit")
               } # close min else
      } else if (gaus) {Report[1,(reportcolno - 12):(reportcolno - 10)] <- c(paste("simp turned off"),
                                                                   paste("simp turned off"),
                                                                   paste("simp turned off"))
              } else {# if not running gaus, report cols are changed so needs adjustment
                Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste("simp turned off"),
                                                                     paste("simp turned off"),
                                                                     paste("simp turned off"))
              } # close simp else

      if (gaus) {Report[1:(length(Bin_Bars[,1])),(reportcolno - 9)] <- as.character(Bin_Bars$var)
      } else {Report[1:(length(Bin_Bars[,1])),(reportcolno - 2)] <- as.character(Bin_Bars$var)}

      if (gaus) {Report[1:(length(Bin_Bars[,2])),(reportcolno - 8)] <- as.character(Bin_Bars$rel.inf)
      } else {Report[1:(length(Bin_Bars[,2])),(reportcolno - 1)] <- as.character(Bin_Bars$rel.inf)}
      # only do final variable interaction lines if varint=TRUE
      if (varint) {
        if (gaus) {Report[1:2,(reportcolno - 7)] <- c(paste(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1], sep = ""),
                                                       paste(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2], sep = ""))
                  } else {Report[1:2,(reportcolno)] <- c(paste(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1], sep = ""),
                                                           paste(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2], sep = ""))
                          } # close varint not gaus
                   } else {if (gaus) {Report[1,(reportcolno - 7)] <- paste("varint turned off")
                                     } else {Report[1,(reportcolno)] <- paste("varint turned off")
                                            } # close not varint not gaus
                          } # close not varint
    } # close ZI

    if (gaus) {Report[1:2,(reportcolno - 6)] <- c(paste("Model combo: ", Gaus_Best_Name, sep = ""), paste("Model CV score: ", Gaus_Best_Score, sep = ""))
    if (simp) {Report[1:dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 5)] <- as.character(subset(Gaus_Best_Simp_Check$final.drops ,order > 0)$preds)
    Report[1:(length(Gaus_Best_Simp_Check$final.drops$preds) - dim(subset(Gaus_Best_Simp_Check$final.drops, order > 0))[1]), (reportcolno - 4)] <-
      as.character(Gaus_Best_Simp_Check$final.drops$preds[((dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Gaus_Best_Simp_Check$final.drops$preds)])
    if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0) {
      Report[1:6,(reportcolno - 3)] <- c(paste("trees: ", Gaus_Best_Simp$n.trees, sep = ""),
                                         paste("Training Data Correlation: ", Gaus_Best_Simp$self.statistics$correlation[[1]], sep = ""),
                                         paste("CV Mean Deviance: ", Gaus_Best_Simp$cv.statistics$deviance.mean, sep = ""),
                                         paste("CV Deviance SE: ", Gaus_Best_Simp$cv.statistics$deviance.se, sep = ""),
                                         paste("CV Mean Correlation: ", Gaus_Best_Simp$cv.statistics$correlation.mean, sep = ""),
                                         paste("CV Correlation SE: ", Gaus_Best_Simp$cv.statistics$correlation.se, sep = ""))} else {
                                           Report[1,(reportcolno - 3)] <- paste("No simplification benefit")} # close min check
    } else {Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste("simp turned off"),
                                                               paste("simp turned off"),
                                                               paste("simp turned off"))} # close simp
    Report[1:(length(Gaus_Bars[,1])),(reportcolno - 2)] <- as.character(Gaus_Bars$var)
    Report[1:(length(Gaus_Bars[,2])),(reportcolno - 1)] <- as.character(Gaus_Bars$rel.inf)
    # only do final variable interaction lines if varint=TRUE
    if (varint)
      {Report[1:2,(reportcolno)] <- c(paste(find.int_Gaus$rank.list$var1.names[1]," and ",find.int_Gaus$rank.list$var2.names[1],". Size: ",find.int_Gaus$rank.list$int.size[1], sep = ""),
                                                paste(find.int_Gaus$rank.list$var1.names[2]," and ",find.int_Gaus$rank.list$var2.names[2],". Size: ",find.int_Gaus$rank.list$int.size[2], sep = ""))
    } else {Report[1,(reportcolno)] <- paste("varint turned off")}}
    write.csv(Report, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Report.csv", sep = ""))

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Report CSV written      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    if (!is.null(grids)) { #avoid sections 22&23 if not predicting to grids

      ####23. Unrepresentativeness surface builder####
      # builds doesn't plot surface. If built, plotted by map maker.
      if (RSB) {
        rsbdf_bin <- gbm.rsb(samples, grids, expvarnames, gridslat, gridslon)
        pos_samples <- subset(samples, brv > 0)
        if (gaus) {rsbdf_gaus <- gbm.rsb(pos_samples, grids, expvarnames, gridslat, gridslon)
        rsbdf_both <- data.frame(rsbdf_bin, "Unrep_Gaus" = rsbdf_gaus[,"Unrepresentativeness"], "Unrep_Both" = (rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"]))
        write.csv(rsbdf_both, row.names = FALSE, file = paste("./", names(samples[i]), "/RSB.csv", sep = ""))
        } else write.csv(rsbdf_bin, row.names = FALSE, file = paste("./", names(samples[i]), "/RSB.csv", sep = ""))
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       RSB CSV written       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

      ####24. Map maker####
      if (map == TRUE) {   # generate output image & set parameters
        png(filename = paste("./",names(samples[i]),"/PredAbundMap_",names(samples[i]),".png", sep = ""),
            width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
        par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
        # run gbm.map function with generated parameters
        gbm.map(x = grids[,gridslon],
                y = grids[,gridslat],
                z = grids[,predabund],
                species = names(samples[i]),
                shape = shape, #either autogenerated or set by user so never blank
                ...)  # allows gbm.auto's optional terms to be passed to subfunctions:
        # byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
        dev.off()

        if (alerts) beep(2) # progress printer, right aligned for visibility
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Reticulating splines     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Colour map generated     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

        if (BnW) { # if BnW=TRUE, run again in black & white for journal submission
          png(filename = paste("./",names(samples[i]),"/PredAbundMap_BnW_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = grids[,predabund],
                  species = names(samples[i]),
                  shape = shape, #either autogenerated or set by user so never blank
                  landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
                  mapback = "white",
                  heatcolours = grey.colors(8, start = 1, end = 0))
          dev.off()
          if (alerts) beep(2)  # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Black & white map generated XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
        } # close & save plotting device & close BnW optional

        if (RSB == TRUE) { # if RSB called, plot that surface separately
          png(filename = paste("./",names(samples[i]),"/RSB_Map_Bin_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon], # add Unrepresentativeness alpha surface
                  y = grids[,gridslat],
                  z = rsbdf_bin[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-1",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
          dev.off() #high value log breaks mean first ~5 values cluster near 0 for high
          # res there, but high values captures in the last few bins.

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Colour RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          if (gaus) {png(filename = paste("./",names(samples[i]),"/RSB_Map_Gaus_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = rsbdf_gaus[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-1",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
          dev.off()

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          png(filename = paste("./",names(samples[i]),"/RSB_Map_Both_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-2",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/1000)
          dev.off()

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

          if (BnW) {     # if BnW=TRUE, do again for b&w
            png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Bin_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_bin[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0), #default 8 greys
                    ####BUG:setting heatcolours & colournumber overrides this####
                    landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
                    legendtitle = "UnRep 0-1",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
            dev.off()

            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     B&W RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

            if (gaus) {png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Gaus_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_gaus[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0),
                    landcol = grey.colors(1, start = 0.8, end = 0.8),
                    legendtitle = "UnRep 0-1",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
            dev.off()

            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

            png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Both_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0),
                    landcol = grey.colors(1, start = 0.8, end = 0.8),
                    legendtitle = "UnRep 0-2",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/1000)
            dev.off()
            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}
          } # close BnW RSBs
        } # close RSB mapper
      } # close Map Maker
    } #close grids option from above section 22
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Grids/maps/everything done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
  } # close response variable (resvar) loop
  if (alerts) beep(8)} # final user notification, then close the function
####END####
