# [1] is the first item of the dim list of rows & columns, i.e. rows
Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 11)] <-
as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])
# listing simp predictors dropped.
if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:14,(reportcolno - 10)] <- c(paste0("trees: ", Bin_Best_Simp$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Simp$self.statistics$correlation[[1]], 3)),
paste0("Training data AUC score: ", round(Bin_Best_Simp$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(Bin_Best_Simp$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(Bin_Best_Simp$self.statistics$discrimination - Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(Bin_Best_Simp$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(Bin_Best_Simp$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(Bin_Best_Simp$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(Bin_Best_Simp$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(Bin_Best_Simp$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(Bin_Best_Simp$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$self.statistics$mean.resid) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$cv.statistics$deviance.mean) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # if min
Report[1,(reportcolno - 10)] <- paste0("No simplification benefit")
} # close if min else
} else { # bin predictors etc
Report[1:dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1], (reportcolno - 5)] <- as.character(subset(Bin_Best_Simp_Check$final.drops, order > 0)$preds)
Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 4)] <-
as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])
if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:14,(reportcolno - 3)] <- c(paste0("trees: ", Bin_Best_Simp$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Simp$self.statistics$correlation[[1]], 3)),
paste0("Training data AUC score: ", round(Bin_Best_Simp$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(Bin_Best_Simp$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(Bin_Best_Simp$self.statistics$discrimination - Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(Bin_Best_Simp$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(Bin_Best_Simp$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(Bin_Best_Simp$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(Bin_Best_Simp$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(Bin_Best_Simp$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(Bin_Best_Simp$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$self.statistics$mean.resid) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$cv.statistics$deviance.mean) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # if min bin best simp
Report[1,(reportcolno - 3)] <- paste0("No simplification benefit")
} # close if min bin best simp else
} # close bin half of bin/gaus option. Next line is 2nd half of simp option i.e. not simplified
} else if (gaus) { # if not simp but is gaus
Report[1,(reportcolno - 12):(reportcolno - 10)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} else {# not gaus not simp: report cols are changed so needs adjustment
Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} # close 2nd half of simp else, i.e. nosimp bin. Closes bin & gaus simp stats (or no simp notes)
if (gaus) { # if zi & gaus again, second section
Report[1:(length(Bin_Bars[,1])),(reportcolno - 9)] <- as.character(Bin_Bars$var)
} else { # if zi & bin only
Report[1:(length(Bin_Bars[,1])),(reportcolno - 2)] <- as.character(Bin_Bars$var)
} # close ifelse best bin variables rel inf names ordered
if (gaus) { # if ZI & gaus again
Report[1:(length(Bin_Bars[,2])),(reportcolno - 8)] <- as.character(round(Bin_Bars$rel.inf), 2)
} else { # zi & not gaus
Report[1:(length(Bin_Bars[,2])),(reportcolno - 1)] <- as.character(round(Bin_Bars$rel.inf), 2)
} # close ifelse best bin variables rel inf scores
if (varint) { # only do final variable interaction lines if varint=TRUE
if (gaus) { # varint gaus
# Report[1:2,(reportcolno - 7)] <- c(paste0(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1]),
#                                    paste0(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2]))
# 2020-12-17 update, see below
for (v in 1:min(length(which(find.int_Bin$rank.list$int.size > 0)),
nrow(Report))) {
Report[v, (reportcolno - 7)] <- paste0(find.int_Bin$rank.list$var1.names[v]," and ",find.int_Bin$rank.list$var2.names[v],". Size: ",find.int_Bin$rank.list$int.size[v])
}
} else { # varint yes gaus no
# Report[1:2,(reportcolno)] <- c(paste0(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1]),
#                                paste0(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2]))
# 2020-12-17 update, see below
for (u in 1:min(length(which(find.int_Bin$rank.list$int.size > 0)),
nrow(Report))) {
Report[u, (reportcolno)] <- paste0(find.int_Bin$rank.list$var1.names[u]," and ",find.int_Bin$rank.list$var2.names[u],". Size: ",find.int_Bin$rank.list$int.size[u])
}
} # close varint yes gaus no
} else { # varint no
if (gaus) { # varint no gaus yes
Report[1,(reportcolno - 7)] <- paste0("varint turned off")
} else { # varint no gaus no
Report[1,(reportcolno)] <- paste0("varint turned off")
} # close not varint not gaus
} # close not varint
} # close ZI way further up start of report section (L810)
if (gaus) {
Report[1:11 ,(reportcolno - 6)] <- c(paste0("Model combo: ", Gaus_Best_Name),
paste0("trees: ", get(Gaus_Best_Model)$n.trees),  # new, might not work
paste0("Training Data Correlation: ", round(Gaus_Best_Score, 3)),
paste0("CV Mean Deviance: ", round(get(Gaus_Best_Model)$cv.statistics$deviance.mean, 3)), # new, might not work
paste0("CV Deviance SE: ", round(get(Gaus_Best_Model)$cv.statistics$deviance.se, 3)), # new, might not work
paste0("CV D squared: ", round(get(Gaus_Best_Model)$cv.statistics$d.squared, 3)), # new, might not work
paste0("CV Mean Correlation: ", round(get(Gaus_Best_Model)$cv.statistics$correlation.mean, 3)), # new, might not work
paste0("CV Correlation SE: ", round(get(Gaus_Best_Model)$cv.statistics$correlation.se, 3)), # new, might not work
paste0("CV RMSE: ", round(get(Gaus_Best_Model)$cv.statistics$cv.rmse, 3)), # new, might not work
paste0("Deviance% explained relative to null, training: ", round(((get(Gaus_Best_Model)$self.statistics$mean.null - get(Gaus_Best_Model)$self.statistics$mean.resid) / get(Gaus_Best_Model)$self.statistics$mean.null)*100, 2)), # new, might not work
paste0("Deviance% explained relative to null, CV: ", round(((get(Gaus_Best_Model)$self.statistics$mean.null - get(Gaus_Best_Model)$cv.statistics$deviance.mean) / get(Gaus_Best_Model)$self.statistics$mean.null)*100, 2))) # new, might not work
if (simp) {
Report[1:dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 5)] <- as.character(subset(Gaus_Best_Simp_Check$final.drops ,order > 0)$preds)
Report[1:(length(Gaus_Best_Simp_Check$final.drops$preds) - dim(subset(Gaus_Best_Simp_Check$final.drops, order > 0))[1]), (reportcolno - 4)] <-
as.character(Gaus_Best_Simp_Check$final.drops$preds[((dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Gaus_Best_Simp_Check$final.drops$preds)])
if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:10, (reportcolno - 3)] <- c(paste0("trees: ", Gaus_Best_Simp$n.trees),
paste0("Training Data Correlation: ", Gaus_Best_Simp$self.statistics$correlation[[1]]),
paste0("CV Mean Deviance: ", Gaus_Best_Simp$cv.statistics$deviance.mean),
paste0("CV Deviance SE: ", Gaus_Best_Simp$cv.statistics$deviance.se),
paste0("CV D squared: ", Gaus_Best_Simp$cv.statistics$d.squared),
paste0("CV Mean Correlation: ", Gaus_Best_Simp$cv.statistics$correlation.mean),
paste0("CV Correlation SE: ", Gaus_Best_Simp$cv.statistics$correlation.se),
paste0("CV RMSE: ", Gaus_Best_Simp$cv.statistics$cv.rmse),
paste0("Deviance% explained relative to null, training: ", round(((Gaus_Best_Simp$self.statistics$mean.null - Gaus_Best_Simp$self.statistics$mean.resid) / Gaus_Best_Simp$self.statistics$mean.null)*100, 2)), # new, might not work
paste0("Deviance% explained relative to null, CV: ", round(((Gaus_Best_Simp$self.statistics$mean.null - Gaus_Best_Simp$cv.statistics$deviance.mean) / Gaus_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # else if min gaus best simp, stats where simp benefit true, open note where no simp benefit
Report[1,(reportcolno - 3)] <- paste0("No simplification benefit")
} # close if else simp benefit check
} else { # close gaus yes simp yes, do gaus yes simp no
Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} # close simp, still in gaus yes
Report[1:(length(Gaus_Bars[,1])),(reportcolno - 2)] <- as.character(Gaus_Bars$var)
Report[1:(length(Gaus_Bars[,2])),(reportcolno - 1)] <- as.character(round(Gaus_Bars$rel.inf), 2)
if (varint) { # gaus yes varint yes
# 2020.12.17 instead of top 2 interactions, do all of them that are > 0 size (unless there are more than the report nrow)
for (t in 1:min(length(which(find.int_Gaus$rank.list$int.size > 0)),
nrow(Report))) {
Report[t, (reportcolno)] <- paste0(find.int_Gaus$rank.list$var1.names[t]," and ",find.int_Gaus$rank.list$var2.names[t],". Size: ",find.int_Gaus$rank.list$int.size[t])
}
# Report[1:2,(reportcolno)] <- c(paste0(find.int_Gaus$rank.list$var1.names[1]," and ",find.int_Gaus$rank.list$var2.names[1],". Size: ",find.int_Gaus$rank.list$int.size[1]),
#                                paste0(find.int_Gaus$rank.list$var1.names[2]," and ",find.int_Gaus$rank.list$var2.names[2],". Size: ",find.int_Gaus$rank.list$int.size[2]))
} else { # gaus yes varint no
Report[1,(reportcolno)] <- paste0("varint turned off")
} # close varint yes no, still in gaus yes
} # close gaus if
View(Report)
tmp <- Report
tmp[, "Buttholes"] <- c(1,2,3,4)
tmp[, "Buttholes"] <- as.character(NA)
View(tmp)
tmp <- Report
tmp[, "Metadata"] <- as.character(NA)
View(tmp)
tmp$Metadata[1:4]
samples[i]
i
length(samples[i])
i
samples[, i]
length(samples[, i])
names(samples[i])
grv_yes[, i]
length(grv_yes[, i])
tmp$Metadata[1:4] <- c(
paste0("gbm.auto v", packageVersion("gbm.auto")),
paste0("dismo v", packageVersion("dismo")),
paste0("fam1 n ", length(samples[, i])),
ifelse(gaus, paste0("fam2 n ", length(grv_yes[, i])), as.character(NA))
)
Report[, "Metadata"] <- as.character(NA)
Report$Metadata[1:4] <- c(
paste0("gbm.auto v", packageVersion("gbm.auto")),
paste0("dismo v", packageVersion("dismo")),
paste0("fam1 n ", length(samples[, i])),
ifelse(gaus, paste0("fam2 n ", length(grv_yes[, i])), as.character(NA))
)
write.csv(Report, row.names = FALSE, na = "", file = paste0("./", names(samples[i]), "/Report.csv"))
sum(samples[,i] == 0, na.rm = TRUE)
sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i])
round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3)
paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100)
paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes")
Report[1,3]
Report[2,3]
Report[2,3] <- paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes")
Report[2,3]
library(devtools)
document()
build()
library(devtools)
document()
build()
library(devtools)
document()
build()
grids = NULL
offset = NULL
n.trees = 50
ZI = "CHECK"
fam2 = c("gaussian", "bernoulli", "binomial", "poisson", "laplace")
gridslat = 2
gridslon = 1
multiplot = TRUE
cols = grey.colors(1,1,1)
linesfiles = TRUE
smooth = FALSE
savedir = tempdir()
savegbm = TRUE
loadgbm = NULL
varint = TRUE
map = TRUE
shape = NULL
RSB = TRUE
BnW = TRUE
alerts = TRUE
pngtype = c("cairo-png", "quartz", "Xlib")
gaus = TRUE
MLEvaluate = TRUE
brv = NULL
grv = NULL
Bin_Preds = NULL
Gaus_Preds = NULL
drumline <- readRDS(file = "/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Data/2023-04-04_drumline_reefs.rds")
samples = as.data.frame(drumline)
expvar = c("Habitat", "Tide", "Season", "LunarPhase", "Latitude", "Longitude", "Depth_m", "Temperature_C", "Hour", "Yearday", "Month", "DtDropOff")
resvar = "CaribbeanReef_CPUE"
randomvar = TRUE
tc = 13
# lr = list(0.001, 0.0000001),
lr = list(0.01, c(0.0000001, 0.1))
bf = 0.9
fam1 = "bernoulli"
smooth = TRUE
simp = FALSE
savegbm = FALSE
MLEvaluate = TRUE
savedir = paste0("../../Projects/2021-10_Drumline_Reefshark/BRT/")
BnW = FALSE
oldpar <- par(no.readonly = TRUE) # defensive block, thanks to Gregor Sayer
oldwd <- getwd()
oldoptions <- options()
on.exit(dev.off()) # close any open graphics devices to avoid issues later
on.exit(par(oldpar))
on.exit(setwd(oldwd), add = TRUE)
on.exit(options(oldoptions), add = TRUE)
setwd(savedir)
if (alerts) options(error = function() {
beep(9)# give warning noise if it fails
graphics.off()# kill all graphics devices
setwd(oldwd) # reinstate original working directory. Probably redundant given on.exit
} # close options subcurly
) # close options
savedir
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/"
setwd(savedir)
if (alerts) options(error = function() {
beep(9)# give warning noise if it fails
graphics.off()# kill all graphics devices
setwd(oldwd) # reinstate original working directory. Probably redundant given on.exit
} # close options subcurly
) # close options
fam1 <- match.arg(fam1) # populate object from function argument in proper way
fam2 <- match.arg(fam2)
pngtype <- match.arg(pngtype)
if (fam1 == "binomial") fam1 <- "bernoulli" # gbm::gbm doesn't like binomial even though it's the same
if (fam2 == "binomial") fam2 <- "bernoulli"
if (gaus) if (fam2 == fam1) stop("attempting to run delta model with both families the same. Expects fam1==bernoulli & gaus==TRUE & fam2==somethingElse, OR fam1==anything & gaus==FALSE")
# tibble's don't collapse into a vector, instead an X x 1 df, which breaks various functionality.
if ("tbl" %in% class(grids)) grids <- as.data.frame(grids)
if ("tbl" %in% class(samples)) samples <- as.data.frame(samples)
# create basemap using gbm.basemap & these bounds, else basemap will be called for every map
if (!is.null(grids)) if (map) { # create basemap grids not null, map requested, basemap not provided
if (is.null(shape)) {
if (!exists("gbm.basemap")) {stop("you need to install gbm.basemap to run this function")}
bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
#create standard bounds from data, and extra bounds for map aesthetic
# xmid <- mean(bounds[1:2])
# ymid <- mean(bounds[3:4])
# xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
# xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
# yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
# yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
# extrabounds <- c(xextramin, xextramax, yextramin, yextramax) # identical code to what's in basemap
shape <- gbm.basemap(bounds = bounds,
savedir = savedir,
extrabounds = TRUE)
} # close isnull shape
} # close isnull grids
if (randomvar) { # add random variable if requested
samples$randomvar <- runif(n = nrow(drumline), min = 0, max = 1)  # make it then add to expvar & thus expvarnames
if (is.numeric(expvar)) expvar <- c(expvar, which(colnames(samples) %in% "randomvar")) else expvar <- c(expvar, "randomvar")
}
expvarnames <- if (is.numeric(expvar)) names(samples[expvar]) else expvar # list of explanatory variable names
if (!length(cols) == 1 & !length(cols) == length(expvarnames)) stop("length of cols is neither the same as the length of expvars (plus randomvar if selected) nor 1")
if (length(cols) == 1) cols <- rep(cols, length(expvarnames)) # if cols is length 1, repeat it so it attaches properly next
expvarcols <- cbind(cols[1:length(expvarnames)],expvarnames) # assign explanatory variables to colours
if (!is.null(offset)) {
if (is.character(offset)) offset <- which(colnames(samples) %in% offset) # if offset is the column name, change to column number
colnames(samples)[offset] <- "offset" # then change name to "offset"
}
if (is.list(tc)) { # if lists entered for tc lr or bf, split them to bin and gaus
if (length(tc) > 2) {stop("Only 2 tc list items allowed: 1 per family")}
tcgaus <- tc[[2]]
tc <- tc[[1]]
} else {tcgaus <- tc} # else make the gaus object the same as the bin. close if else
if (is.list(lr)) {
if (length(lr) > 2) {stop("Only 2 lr list items allowed: 1 per family")}
lrgaus <- lr[[2]]
lr <- lr[[1]]
} else {lrgaus <- lr} # close if else lr
if (is.list(bf)) {
if (length(bf) > 2) {stop("Only 2 bf list items allowed: 1 per family")}
bfgaus <- bf[[2]]
bf <- bf[[1]]
} else {bfgaus <- bf} # close if else bf
if (is.list(n.trees)) { # if list entered n.trees, split to fam1 and fam2
if (length(n.trees) > 2) {stop("Only 2 n.trees list items allowed: 1 per family")}
ntf1 <- n.trees[[1]]
ntf2 <- n.trees[[2]]
} else {
ntf1 <- n.trees
ntf2 <- n.trees} # else make fam1 and fam2 the same. close if else n.trees
i <- resvar
dir.create(names(samples[i])) # create resvar-named directory for outputs
getwd()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/")
getwd()
dir.create(names(samples[i])) # create resvar-named directory for outputs
m = 0 # Gaus only loop counter to allow best gaus BRT choice
n = 0 # Print counter for all loops of BRT combos & best bin BRT choice
if (!is.null(grids)) if (!all(expvarnames %in% names(grids))) stop(print("Expvar column names in samples but missing from grids:"), print(expvarnames[which(!expvarnames %in% names(grids))]))
if (anyNA(samples[i])) stop("Response variable range contains NA values, please filter out these rows with: mysamples <- mysamples[-which(is.na(mysamples[resvar])),]")
####2. ZI check & log####
# if user has asked code to check for ZI, check it & set new ZI status
if (ZI == "CHECK") if (sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]) >= 0.5) ZI = TRUE else ZI = FALSE
# ensure resvar has zeroes (expects mix of successful & unsuccessful samples for bernoulli/binary runs)
if (!ZI) if (min(samples[i]) > 0) print("No zeroes in response variable. If using a zero inflated model, Method expects unsuccessful, as well as successful, samples")
# create binary (0/1) response variable, for bernoulli BRTs
samples$brv <- ifelse(samples[i] > 0, 1, 0)
brvcol <- which(colnames(samples) == "brv") # brv column number for BRT
# create logged response variable, for Gaussian BRTs when data are zero-inflated (otherwise just use resvar directly)
logem <- log1p(samples[,i]) # logs resvar i.e. containing zeroes
dont  <- samples[,i]
# log1p resvar if bin only (fam1 bin, fam2 FALSE), OR if resvar is delta & ZI & NOT poisson (which can't be logged, must be positive integers)
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI & (fam2 != "poisson")))) {samples$grv <- logem} else {samples$grv <- dont}
grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
if (ZI) {
grv_yes <- subset(samples, grv > 0) # nonzero subset for gaussian/poisson BRTs if zero inflated
} else {
grv_yes <- samples # use the full dataset if not ZI
}
####3. Begin Report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) { # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 14
# if only 1 permutation, = 19
} else { # else zi
reportcolno = 3 + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 7
# if only 1 permutation = 11
} # close if else ZI
if (!gaus) reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + 7
# 14: best bin brt, best gaus brt,
# Bin_BRT_simp predictors kept (ordered), Bin_BRT_simp predictors dropped,
# Gaus_BRT_simp predictors kept (ordered),Gaus_BRT_simp predictors dropped,
# Simplified Binary BRT stats, Simplified Gaussian BRT stats,
# Best Binary BRT variables, Relative Influence (Bin),
# Best Gaussian BRT variables, Relative Influence (Gaus),
# Biggest Interactions (Bin), Biggest Interactions (Gaus)
# + 5 elements for each loop: parameter combo n (tc lr & bf values),
# Bin BRT n stats, Bin BRT n name
# Gaus BRT n stats, Gaus BRT n name
Report <- data.frame(matrix(NA, nrow = (max(6,length(expvar))), ncol = (reportcolno)))
# build blank df, rows=biggest of 6 (max static row number of stats) or n of exp. vars
colnames(Report) <- c("Explanatory Variables","Response Variables","Zero Inflated?") # populate static colnames 1:3
# name bin columns if ZI
if (!gaus) {colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")
} else {
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {colnames(Report)[(reportcolno - 13):(reportcolno - 7)] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")}
colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Gaussian BRT",
"Gaus_BRT_simp predictors dropped",
"Gaus_BRT_simp predictors kept",
"Simplified Gaussian BRT stats",
"Best Gaussian BRT variables",
"Relative Influence (Gaus)",
"Biggest Interactions (Gaus)")} # close if else gaus
# populate the final 14 column names
Report[1:length(expvar),1] <- expvarnames # put expvar names in first column # names(samples[expvar])
Report[1,2] <- names(samples[i]) # put resvar in col 2
Report[1,3] <- ZI # ZI in col 3
Report[2,3] <- paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes") # add zeroes % under ZI in col3
StatsObjectsList <- list()
Bin_Best_Score <- 0 # create blanks for best results to use in loops
Bin_Best_Model <- 0
Gaus_Best_Score <- 0
Gaus_Best_Model <- 0
tc
j <- tc
k <- lr
l <- bf
n <- n + 1   # Add to print counter
####4. Binomial BRT####
print(paste0("Running ", fam1, " BRT, tc=",j,", lr=",k,", bf=",l))
assign(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l),
try(gbm.step.sd(data = samples, # try wrapper results in the object being a try-error class if the BRT fails
gbm.x = expvar,
gbm.y = brvcol,
family = fam1,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf1,
{if (!is.null(offset)) offset = grv_yes$offset}))
)
class(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)))
if (class(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))) == "try-error") next # test for BRT failure and skip this hyperparameter combo
dev.print(file = paste0("./",names(samples[i]),"/pred_dev_bin.jpeg"), device = jpeg, width = 600)
print(paste0("Done Bin_BRT",".tc",j,".lr",k,".bf",l))
print(warnings())
# assign("last.warning", NULL, envir = baseenv()) # dumps warnings so subsequent printing doesn't reprint the existing warning
####5. Select best bin model####
if (n == 1) { # if this is the first loop, best score & model name is this one by default
Bin_Best_Score <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]]
Bin_Best_Model <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
# else if this models self.statistics$correlation > the best model, make this the new best model
}  else if (get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]] > Bin_Best_Score) {
Bin_Best_Score <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]]
Bin_Best_Model <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
} # close if else n==1
####6. Add bin stats to report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {Report[1:8,(3 + n)] <- c(paste0("trees: ",round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$n.trees, 3)),
paste0("Training Data Correlation: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]], 3)),
paste0("CV Mean Deviance: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$cv.rmse), 3))
# bin BRT name
colnames(Report)[3 + n] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
# Add Bin stats objects to StatsObjectsList
StatsObjectsList[[length(StatsObjectsList) + 1]] <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics # send to new position after last item
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l, "__self.statistics") # name it. new length now includes self.statistics
StatsObjectsList[[length(StatsObjectsList) + 1]] <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l, "__cv.statistics")
} # close ZI if
if (alerts) beep(2) # progress printer, right aligned
if (gaus) {
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} else { # close if else gaus
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # else if gaus
tcgaus
j <- tcgaus
k <- lrgaus
l <- bfgaus
n <- n + 1 # Add to print/loop counter for every bin or gaus BRT loop
m <- m + 1 # Add to loop counter for Gaus best model selection
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
fam2
fam2 <- "gaussian"
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
tcgaus
lrgaus
lrgaus[2]
k <- lrgaus[2]
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
grv_yes[,grvcol]
grv_yes
# log1p resvar if bin only (fam1 bin, fam2 FALSE), OR if resvar is delta & ZI & NOT poisson (which can't be logged, must be positive integers)
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI & (fam2 != "poisson")))) {samples$grv <- logem} else {samples$grv <- dont}
grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
grvcol
if (ZI) {
grv_yes <- subset(samples, grv > 0) # nonzero subset for gaussian/poisson BRTs if zero inflated
} else {
grv_yes <- samples # use the full dataset if not ZI
}
grv_yes
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
grv_yes
grv_yes[,grvcol]
"./",names(samples[i]),"/grv.csv"
paste0("./",names(samples[i]),"/grv.csv")
getwd()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/")
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
assign(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l),
try(gbm.step.sd(data = grv_yes,
gbm.x = expvar,
gbm.y = grvcol,
family = fam2,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf2,
{if (!is.null(offset)) offset = grv_yes$offset}))
)
paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)
get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l))
is.null(get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)))
if (is.null(get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)))) next
