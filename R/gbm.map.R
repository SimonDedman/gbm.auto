#' Maps of predicted abundance from Boosted Regression Tree modelling
#'
#' Generates maps from the outputs of gbm.step then gbm.predict.grids, handled
#' automatically within gbm.auto but can be run alone, and generates
#' representativeness surfaces from the output of gbm.rsb
#'
#' @param x Vector of longitudes, from make.grid in mapplots; x. Order by this (descending) SECOND
#' @param y Vector of latitudes, from make.grid in mapplots; grids[,gridslat]. Order by this (descending) first
#' @param z Vector of abundances generated by gbm.predict.grids, from make.grid in mapplots; grids[,predabund]
#' @param byx Longitudinal width of grid cell, from make.grid in mapplots. Autogenerated if left blank.
#' @param byy Latitudinal height of grid cell, from make.grid in mapplots. Autogenerated if left blank.
#' @param grdfun make.grid operand for >=2 values per cell. Default:mean, other options: sum prod min max sd se var
#' @param mapmain Output map image response variable title, from basemap in mapplots
#' @param species Response variable name, from basemap in mapplots; names(samples[i]). Defaults to "Response Variable"
#' @param heatcolours Abundance colour scale, defaults to the heatcol from legend.grid and draw.grid in mapplots.
#' @param colournumber number of colours to spread heatcol over, default:8
#' @param shape Basemap shape to draw, from draw.shape in mapplots. Defaults: 'coast': UK and Ire
#' @param landcol Colour for 'null' area of map, if appropriate, from draw.shape in mapplots. Was "darkgreen" changed to light grey
#' @param mapback Basemap background colour, defaults to lightblue
#' @param legendloc Location on map of legend box, from legend.grid in mapplots
#' @param legendtitle The metric of abundance, e.g. CPUE for fisheries, from legend.grid in mapplots
#' @param lejback Background colour of legend, from legend.grid in mapplots
#' @param zero Allow 0 category in breaks.grid and thus legend? Default TRUE
#' @param quantile Set max breakpoint; lower this to cutoff outliers
#' @param byxout Export byx to use elsewhere? Default:FALSE
#' @param breaks Vector of breakpoints for colour scales; default blank, generated automatically
#' @param ... Additional arguments for legend.grid's ... which passes to legend
#'
#' @return Species abundance maps using data provided by gbm.auto, and
#' Representativeness Surface Builder maps using data provided by gbm.rsb, to be
#' run in a png/par/gbm.map/dev.off sequence.
#' @export
#' @import mapplots
#' @author Simon Dedman, \email{simondedman@@gmail.com}
#' @examples Suggested code for outputting to e.g. png:
#' png(...)
#' par(...)
#' gbm.map(x = grids[,gridslon], y = grids[,gridslat], z = grids[,predabund],
#' species = names(samples[i]), legendtitle = mainlegendtitle)
#' dev.off()
#'
#' Suggested parameter values for use with gbm.rsb:
#' z = rsbdf[,"Unrepresentativeness"]
#' mapmain = "Unrepresentativeness: "
#' legendtitle = "UnRep 0-1"
gbm.map <- function(x,        #vector of longitudes, from make.grid in mapplots; x. ##Order by this (descending) SECOND
                    y,        #vector of latitudes, from make.grid in mapplots; grids[,gridslat]. ##Order by this (descending) first
                    z,        #vector of abundances generated by gbm.predict.grids, from make.grid in mapplots; grids[,predabund]
                    byx = NULL,      #longitudinal width of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    byy = NULL,      #latitudinal height of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    grdfun = mean,   #make.grid operand for >=2 values per cell. Default:mean, other options: sum prod min max sd se var
                    mapmain = "Predicted CPUE (numbers per hour): ",  #output map image response variable title, from basemap in mapplots
                    species = "Response Variable",  #Response variable name, from basemap in mapplots; names(samples[i]). Defaults to "Response Variable"
                    heatcolours = c("white", "yellow", "orange","red", "brown4"), #abundance colour scale, defaults to the heatcol from legend.grid & draw.grid in mapplots.
                    colournumber = 8,   #number of colours to spread heatcol over, default:8
                    shape = coast,   #basemap shape to draw, from draw.shape in mapplots. Defaults: 'coast': UK & Ire
                    landcol = "grey80", #colour for 'null' area of map, if appropriate, from draw.shape in mapplots. Was "darkgreen" changed to light grey
                    mapback = "lightblue", #basemap background colour
                    legendloc = "bottomright", #location on map of legend box, from legend.grid in mapplots
                    legendtitle = "CPUE", #the metric of abundance, e.g. CPUE for fisheries, from legend.grid in mapplots
                    lejback = "white",  #background colour of legend, from legend.grid in mapplots
                    zero = TRUE, # allow 0 category in breaks.grid & thus legend? Default TRUE
                    quantile = 1, # set max breakpoint; lower this to cutoff outliers
                    byxout = FALSE, # export byx to use elsewhere? Default:FALSE
                    breaks = NULL, # vector of breakpoints for colour scales; default blank, generated automatically
                    ...) # additional arguments for legend.grid's ... which passes to legend

# Generalised Boosting Models, automated map generator. Simon Dedman, 2014, simondedman@gmail.com, https://github.com/SimonDedman/gbm.auto

# Generates maps from the outputs of gbm.step then gbm.predict.grids, handled automatically within gbm.auto but can be run alone, and
# generates representativeness surfaces from the output of gbm.rsb (suggest: z = rsbdf[,"Unrepresentativeness"],
# mapmain = "Unrepresentativeness: ",legendtitle = "UnRep 0-1"). Suggested code for outputting to e.g. png:
# png(...); par(...); gbm.map(...); dev.off()
{
  require(mapplots)
  library(mapplots)
  # get Britain & Ireland coast data. I'm looking to make this global but am having a problem w/ the maps packge
  if (is.null(shape)) {data(coast, package = "mapplots")}
  # if users hasn't entered byx or byy values, generate them from the data
  if (is.null(byx)) {
    # work out cell size for uniform square gridded data: Create blank vector for grid length calcs
    bydist <- rep(NA, length(x))
    # and attach it to grids
    cells <- data.frame(LONGITUDE = x, bydist = bydist, stringsAsFactors = FALSE)
    # fill it: if [next longitude minus current longitude] equals [current longitude minus previous longitude], that's a uniform cell.
    # data rounded to prevent tiny fluctuations counting as differences. Need to set that tolerance.
    # Could do 10% of average distance between uniform points, but you don't know that til the end!
    cells[2:(length(x) - 1),"bydist"] <-
      ifelse(round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1], digits = 5)
             ==
               round(cells[3:length(x),1] - cells[2:(length(x) - 1),1], digits = 5),
             round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1], digits = 5), NA)
    # Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
    byx <- mean(cells$bydist, na.rm = TRUE)
    byy <- byx
    if (byxout) byxport <<- byx
  }
  grd <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = grdfun) #create gridded data. fun defaults to sum which is bad
  heatcol = colorRampPalette(heatcolours)(colournumber) #create heatcol from component parts
  if (is.null(breaks)) breaks <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol))  #if breaks specified, do nothing (it's used later in draw.grid). Else generate it.
  if (zero) {heatcol = c("#00000000", colorRampPalette(heatcol)(length(heatcol) - 1))} #if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
  basemap(xlim = range(x), ylim = range(y), main = paste(mapmain, species, sep = ""), bg = mapback, xlab = "Longitude", ylab = "Latitude")
  draw.grid(grd, breaks, col = heatcol) # plot grd data w/ breaks for colour breakpoints
  draw.shape(shape = shape, col = landcol) # add coastline
  legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = legendtitle, col = heatcol) #breaks=breaks/1000 was causing odd legend? From make.grid help, Hans using to convert kg to t?
  # removed the '...' from legend.grid, preventing optional args from being passed to legend.
  # Legend doesn't have a '...' so ALL args floating in the environment will be passed
  # and expected to be used. Like max.trees and other gbm args. This kills the crab.
  # Could potentially write out the whole of legend.grid (it's small) then call
  # legend with R.utils::doCall("legend" x, y, legend = legend, col = col[ncol:1], pch = pch,
  ## pt.cex = pt.cex, bg = bg, ..., .ignoreUnusedArgs=TRUE))
  }
