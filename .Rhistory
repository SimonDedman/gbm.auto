Gaus_Best_Score <- 0
Gaus_Best_Model <- 0
tc
j <- tc
k <- lr
l <- bf
n <- n + 1   # Add to print counter
####4. Binomial BRT####
print(paste0("Running ", fam1, " BRT, tc=",j,", lr=",k,", bf=",l))
assign(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l),
try(gbm.step.sd(data = samples, # try wrapper results in the object being a try-error class if the BRT fails
gbm.x = expvar,
gbm.y = brvcol,
family = fam1,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf1,
{if (!is.null(offset)) offset = grv_yes$offset}))
)
class(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)))
if (class(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))) == "try-error") next # test for BRT failure and skip this hyperparameter combo
dev.print(file = paste0("./",names(samples[i]),"/pred_dev_bin.jpeg"), device = jpeg, width = 600)
print(paste0("Done Bin_BRT",".tc",j,".lr",k,".bf",l))
print(warnings())
# assign("last.warning", NULL, envir = baseenv()) # dumps warnings so subsequent printing doesn't reprint the existing warning
####5. Select best bin model####
if (n == 1) { # if this is the first loop, best score & model name is this one by default
Bin_Best_Score <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]]
Bin_Best_Model <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
# else if this models self.statistics$correlation > the best model, make this the new best model
}  else if (get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]] > Bin_Best_Score) {
Bin_Best_Score <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]]
Bin_Best_Model <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
} # close if else n==1
####6. Add bin stats to report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {Report[1:8,(3 + n)] <- c(paste0("trees: ",round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$n.trees, 3)),
paste0("Training Data Correlation: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics$correlation[[1]], 3)),
paste0("CV Mean Deviance: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics$cv.rmse), 3))
# bin BRT name
colnames(Report)[3 + n] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l)
# Add Bin stats objects to StatsObjectsList
StatsObjectsList[[length(StatsObjectsList) + 1]] <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$self.statistics # send to new position after last item
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l, "__self.statistics") # name it. new length now includes self.statistics
StatsObjectsList[[length(StatsObjectsList) + 1]] <- get(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l))$cv.statistics
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0("Bin_BRT",".tc",j,".lr",k,".bf",l, "__cv.statistics")
} # close ZI if
if (alerts) beep(2) # progress printer, right aligned
if (gaus) {
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} else { # close if else gaus
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # else if gaus
tcgaus
j <- tcgaus
k <- lrgaus
l <- bfgaus
n <- n + 1 # Add to print/loop counter for every bin or gaus BRT loop
m <- m + 1 # Add to loop counter for Gaus best model selection
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
fam2
fam2 <- "gaussian"
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
tcgaus
lrgaus
lrgaus[2]
k <- lrgaus[2]
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
grv_yes[,grvcol]
grv_yes
# log1p resvar if bin only (fam1 bin, fam2 FALSE), OR if resvar is delta & ZI & NOT poisson (which can't be logged, must be positive integers)
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI & (fam2 != "poisson")))) {samples$grv <- logem} else {samples$grv <- dont}
grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
grvcol
if (ZI) {
grv_yes <- subset(samples, grv > 0) # nonzero subset for gaussian/poisson BRTs if zero inflated
} else {
grv_yes <- samples # use the full dataset if not ZI
}
grv_yes
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
grv_yes
grv_yes[,grvcol]
"./",names(samples[i]),"/grv.csv"
paste0("./",names(samples[i]),"/grv.csv")
getwd()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/")
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
assign(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l),
try(gbm.step.sd(data = grv_yes,
gbm.x = expvar,
gbm.y = grvcol,
family = fam2,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf2,
{if (!is.null(offset)) offset = grv_yes$offset}))
)
paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)
get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l))
is.null(get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)))
if (is.null(get(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l)))) next
grids = NULL
offset = NULL
n.trees = 50
ZI = "CHECK"
fam2 = "gaussian"
gridslat = 2
gridslon = 1
multiplot = TRUE
cols = grey.colors(1,1,1)
linesfiles = TRUE
loadgbm = NULL
varint = TRUE
map = TRUE
shape = NULL
RSB = TRUE
alerts = TRUE
pngtype = "cairo-png"
gaus = TRUE
brv = NULL
grv = NULL
Bin_Preds = NULL
Gaus_Preds = NULL
drumline <- readRDS(file = "/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Data/2023-04-04_drumline_reefs.rds")
samples = as.data.frame(drumline)
expvar = c("Habitat", "Tide", "Season", "LunarPhase", "Latitude", "Longitude", "Depth_m", "Temperature_C", "Hour", "Yearday", "Month", "DtDropOff")
resvar = "CaribbeanReef_CPUE"
randomvar = TRUE
tc = 13
# lr = list(0.001, 0.0000001),
lr = list(0.01, c(0.0000001, 0.1))
bf = 0.9
fam1 = "bernoulli"
smooth = TRUE
simp = FALSE
savegbm = FALSE
MLEvaluate = TRUE
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/"
BnW = FALSE
setwd("/home/simon/Documents/Si Work/PostDoc Work/Saving The Blue/Projects/2021-10_Drumline_Reefshark/BRT/")
j <- tc
k <- lr
l <- bf
oldpar <- par(no.readonly = TRUE) # defensive block, thanks to Gregor Sayer
oldwd <- getwd()
oldoptions <- options()
on.exit(dev.off()) # close any open graphics devices to avoid issues later
on.exit(par(oldpar))
on.exit(setwd(oldwd), add = TRUE)
on.exit(options(oldoptions), add = TRUE)
setwd(savedir)
if (alerts) options(error = function() {
beep(9)# give warning noise if it fails
graphics.off()# kill all graphics devices
setwd(oldwd) # reinstate original working directory. Probably redundant given on.exit
} # close options subcurly
) # close options
fam1 <- match.arg(fam1) # populate object from function argument in proper way
fam2 = "gaussian"
fam1 = "bernoulli"
pngtype <- match.arg(pngtype)
pngtype
# tibble's don't collapse into a vector, instead an X x 1 df, which breaks various functionality.
if ("tbl" %in% class(grids)) grids <- as.data.frame(grids)
if ("tbl" %in% class(samples)) samples <- as.data.frame(samples)
# create basemap using gbm.basemap & these bounds, else basemap will be called for every map
if (!is.null(grids)) if (map) { # create basemap grids not null, map requested, basemap not provided
if (is.null(shape)) {
if (!exists("gbm.basemap")) {stop("you need to install gbm.basemap to run this function")}
bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
#create standard bounds from data, and extra bounds for map aesthetic
# xmid <- mean(bounds[1:2])
# ymid <- mean(bounds[3:4])
# xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
# xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
# yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
# yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
# extrabounds <- c(xextramin, xextramax, yextramin, yextramax) # identical code to what's in basemap
shape <- gbm.basemap(bounds = bounds,
savedir = savedir,
extrabounds = TRUE)
} # close isnull shape
} # close isnull grids
if (randomvar) { # add random variable if requested
samples$randomvar <- runif(n = nrow(drumline), min = 0, max = 1)  # make it then add to expvar & thus expvarnames
if (is.numeric(expvar)) expvar <- c(expvar, which(colnames(samples) %in% "randomvar")) else expvar <- c(expvar, "randomvar")
}
expvarnames <- if (is.numeric(expvar)) names(samples[expvar]) else expvar # list of explanatory variable names
if (!length(cols) == 1 & !length(cols) == length(expvarnames)) stop("length of cols is neither the same as the length of expvars (plus randomvar if selected) nor 1")
if (length(cols) == 1) cols <- rep(cols, length(expvarnames)) # if cols is length 1, repeat it so it attaches properly next
expvarcols <- cbind(cols[1:length(expvarnames)],expvarnames) # assign explanatory variables to colours
if (!is.null(offset)) {
if (is.character(offset)) offset <- which(colnames(samples) %in% offset) # if offset is the column name, change to column number
colnames(samples)[offset] <- "offset" # then change name to "offset"
}
if (is.list(tc)) { # if lists entered for tc lr or bf, split them to bin and gaus
if (length(tc) > 2) {stop("Only 2 tc list items allowed: 1 per family")}
tcgaus <- tc[[2]]
tc <- tc[[1]]
} else {tcgaus <- tc} # else make the gaus object the same as the bin. close if else
if (is.list(lr)) {
if (length(lr) > 2) {stop("Only 2 lr list items allowed: 1 per family")}
lrgaus <- lr[[2]]
lr <- lr[[1]]
} else {lrgaus <- lr} # close if else lr
if (is.list(bf)) {
if (length(bf) > 2) {stop("Only 2 bf list items allowed: 1 per family")}
bfgaus <- bf[[2]]
bf <- bf[[1]]
} else {bfgaus <- bf} # close if else bf
if (is.list(n.trees)) { # if list entered n.trees, split to fam1 and fam2
if (length(n.trees) > 2) {stop("Only 2 n.trees list items allowed: 1 per family")}
ntf1 <- n.trees[[1]]
ntf2 <- n.trees[[2]]
} else {
ntf1 <- n.trees
ntf2 <- n.trees} # else make fam1 and fam2 the same. close if else n.trees
i <- resvar
dir.create(names(samples[i])) # create resvar-named directory for outputs
m = 0 # Gaus only loop counter to allow best gaus BRT choice
n = 0 # Print counter for all loops of BRT combos & best bin BRT choice
if (!is.null(grids)) if (!all(expvarnames %in% names(grids))) stop(print("Expvar column names in samples but missing from grids:"), print(expvarnames[which(!expvarnames %in% names(grids))]))
if (anyNA(samples[i])) stop("Response variable range contains NA values, please filter out these rows with: mysamples <- mysamples[-which(is.na(mysamples[resvar])),]")
####2. ZI check & log####
# if user has asked code to check for ZI, check it & set new ZI status
if (ZI == "CHECK") if (sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]) >= 0.5) ZI = TRUE else ZI = FALSE
# ensure resvar has zeroes (expects mix of successful & unsuccessful samples for bernoulli/binary runs)
if (!ZI) if (min(samples[i]) > 0) print("No zeroes in response variable. If using a zero inflated model, Method expects unsuccessful, as well as successful, samples")
# create binary (0/1) response variable, for bernoulli BRTs
samples$brv <- ifelse(samples[i] > 0, 1, 0)
brvcol <- which(colnames(samples) == "brv") # brv column number for BRT
# create logged response variable, for Gaussian BRTs when data are zero-inflated (otherwise just use resvar directly)
logem <- log1p(samples[,i]) # logs resvar i.e. containing zeroes
dont  <- samples[,i]
# log1p resvar if bin only (fam1 bin, fam2 FALSE), OR if resvar is delta & ZI & NOT poisson (which can't be logged, must be positive integers)
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI & (fam2 != "poisson")))) {samples$grv <- logem} else {samples$grv <- dont}
grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
if (ZI) {
grv_yes <- subset(samples, grv > 0) # nonzero subset for gaussian/poisson BRTs if zero inflated
} else {
grv_yes <- samples # use the full dataset if not ZI
}
grv_yes
####3. Begin Report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) { # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 14
# if only 1 permutation, = 19
} else { # else zi
reportcolno = 3 + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 7
# if only 1 permutation = 11
} # close if else ZI
if (!gaus) reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + 7
# 14: best bin brt, best gaus brt,
# Bin_BRT_simp predictors kept (ordered), Bin_BRT_simp predictors dropped,
# Gaus_BRT_simp predictors kept (ordered),Gaus_BRT_simp predictors dropped,
# Simplified Binary BRT stats, Simplified Gaussian BRT stats,
# Best Binary BRT variables, Relative Influence (Bin),
# Best Gaussian BRT variables, Relative Influence (Gaus),
# Biggest Interactions (Bin), Biggest Interactions (Gaus)
# + 5 elements for each loop: parameter combo n (tc lr & bf values),
# Bin BRT n stats, Bin BRT n name
# Gaus BRT n stats, Gaus BRT n name
Report <- data.frame(matrix(NA, nrow = (max(6,length(expvar))), ncol = (reportcolno)))
# build blank df, rows=biggest of 6 (max static row number of stats) or n of exp. vars
colnames(Report) <- c("Explanatory Variables","Response Variables","Zero Inflated?") # populate static colnames 1:3
# name bin columns if ZI
if (!gaus) {colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")
} else {
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {colnames(Report)[(reportcolno - 13):(reportcolno - 7)] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")}
colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Gaussian BRT",
"Gaus_BRT_simp predictors dropped",
"Gaus_BRT_simp predictors kept",
"Simplified Gaussian BRT stats",
"Best Gaussian BRT variables",
"Relative Influence (Gaus)",
"Biggest Interactions (Gaus)")} # close if else gaus
# populate the final 14 column names
Report[1:length(expvar),1] <- expvarnames # put expvar names in first column # names(samples[expvar])
Report[1,2] <- names(samples[i]) # put resvar in col 2
Report[1,3] <- ZI # ZI in col 3
Report[2,3] <- paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes") # add zeroes % under ZI in col3
StatsObjectsList <- list()
Bin_Best_Score <- 0 # create blanks for best results to use in loops
Bin_Best_Model <- 0
Gaus_Best_Score <- 0
Gaus_Best_Model <- 0
j <- tc
k <- lr
l <- bf
n <- n + 1   # Add to print counter
####4. Binomial BRT####
print(paste0("Running ", fam1, " BRT, tc=",j,", lr=",k,", bf=",l))
assign(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l),
gbm.step.sd(data = samples,
gbm.x = expvar,
gbm.y = brvcol,
family = fam1,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf1,
{if (!is.null(offset)) offset = grv_yes$offset})
)
assign(paste0("Bin_BRT",".tc",j,".lr",k,".bf",l),
gbm.step.sd(data = samples,
gbm.x = expvar,
gbm.y = brvcol,
family = fam1,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf1,
{if (!is.null(offset)) offset = grv_yes$offset})
)
seq(from = 0, to = 1, length.out = 9)
linear01seq <- seq(from = 0, to = 1, length.out = 9) #linear sequence from 0:1, 9 bins
exp01seq <- expm1(4*linear01seq)/expm1(4) # exponentiate to change shape then scale back to 1
exp01seq
plot(linear01seq,linear01seq)
plot(linear01seq,exp01seq)
?gbm.plot
??gbm.plot
library(dismo)
library(raster)
install.packages("raster")
sudo apt install terra
install.packages("terra")
install.packages("raster")
library(dismo)
install.packages("dismo")
library(dismo)
install.packages("terra")
library(terra)
library(dismo)
gbm.plot
?gbm.plot
library(devtools)
document()
remotes::install_github("rspatial/dismo")
document()
install.packages("sf")
install.packages(rgdal)
install.packages("rgdal"!)
install.packages("rgdal")
document()
library(devtools)
document()
remotes::install_github("SimonDedman/gbm.auto")
siwd <- "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/Courtney Knaur/"
setwd(siwd)
library(gbm.auto)
library(dplyr)
data <- data.frame(read.csv("TowDiverTotalCSV2.csv", header = TRUE, as.is = TRUE)) # importing CSV#
data$TourismPresence <- as.factor(data$TourismPresence)
data$IslandorMainland <- as.factor(data$IslandorMainland)
data$Location <- as.factor(data$Location)
data$Year <- as.factor(data$Year)
# full test
gbm.auto(
grids = NULL,
samples = data,
expvar = c(
"Year",
"Location",
"Temp.",
"Salinity.",
"DO.",
"Cond.",
"X.Boats",
"X.CC",
"TourismPresence",
"IslandorMainland",
"StartDepth"
),
resvar = "Total.Turtle",
tc = c(1, 2, 3, 4, 5), # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do (from 1-5)
lr = c(0.0005, 0.001, 0.005, 0.01),
# granularity of learning rate, check Elith for numbers
bf = c(0.5, 0.55, 0.60, 0.65, 0.7, 0.75),
# put in series of values because it is the percent of data that is used to train the program then run again with the best option
# typical range is 0.5 to 0.75
n.trees = 50,
ZI = "CHECK",
fam1 = c("binomial"), # if you want a poisson distribution need to select, will auto select Gaussian unless zero inflated
fam2 = c("poisson"), #
simp = TRUE, # Change to true
gridslat = 2,
gridslon = 1,
multiplot = TRUE,
cols = grey.colors(1, 1, 1),
linesfiles = TRUE, # change to true for final run
smooth = TRUE,
# sd edit ####
savedir = siwd,
savegbm = TRUE, # change to true for final runs
loadgbm = NULL,
varint = TRUE,
map = TRUE,
shape = NULL,
RSB = TRUE,
BnW = TRUE,
alerts = TRUE, # this is the noise alerts
pngtype = c("cairo-png"), # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE,
MLEvaluate = TRUE,
brv = NULL,
grv = NULL,
Bin_Preds = NULL,
Gaus_Preds = NULL
)
plot(1:10, 1:10)
mtext("Marginal Effect", side = 2, line = 4.05, las = 0)
abline(h = 0)
plot(-5:5, -5:5)
abline(h = 0)
abline(h = 0, lty = 2)
plot(-5:5, -5:5)
abline(h = 0, lty = 2)
?gbm.plot
remotes::install_github("SimonDedman/gbm.auto")
siwd <- "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/Courtney Knaur/"
setwd(siwd)
library(gbm.auto)
library(dplyr)
data <- data.frame(read.csv("TowDiverTotalCSV2.csv", header = TRUE, as.is = TRUE)) # importing CSV#
data$TourismPresence <- as.factor(data$TourismPresence)
data$IslandorMainland <- as.factor(data$IslandorMainland)
data$Location <- as.factor(data$Location)
data$Year <- as.factor(data$Year)
# full test
gbm.auto(
grids = NULL,
samples = data,
expvar = c(
"Year",
"Location",
"Temp.",
"Salinity.",
"DO.",
"Cond.",
"X.Boats",
"X.CC",
"TourismPresence",
"IslandorMainland",
"StartDepth"
),
resvar = "Total.Turtle",
tc = c(1, 2, 3, 4, 5), # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do (from 1-5)
# lr = c(0.0005, 0.001, 0.005, 0.01),
lr = c(0.01),
# granularity of learning rate, check Elith for numbers
# bf = c(0.5, 0.55, 0.60, 0.65, 0.7, 0.75),
bf = c(0.5),
# put in series of values because it is the percent of data that is used to train the program then run again with the best option
# typical range is 0.5 to 0.75
n.trees = 50,
ZI = "CHECK",
fam1 = c("binomial"), # if you want a poisson distribution need to select, will auto select Gaussian unless zero inflated
fam2 = c("poisson"), #
simp = TRUE, # Change to true
gridslat = 2,
gridslon = 1,
multiplot = TRUE,
cols = grey.colors(1, 1, 1),
linesfiles = TRUE, # change to true for final run
smooth = TRUE,
# sd edit ####
savedir = siwd,
savegbm = TRUE, # change to true for final runs
loadgbm = NULL,
varint = TRUE,
map = TRUE,
shape = NULL,
RSB = TRUE,
BnW = TRUE,
alerts = TRUE, # this is the noise alerts
pngtype = c("cairo-png"), # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE,
MLEvaluate = TRUE,
brv = NULL,
grv = NULL,
Bin_Preds = NULL,
Gaus_Preds = NULL
)
gbm.plot
dismo::gbm.plot
remotes::install_github("SimonDedman/gbm.auto")
