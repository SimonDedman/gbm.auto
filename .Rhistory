bag.fraction = get(Bin_Best_Model)$gbm.call$bag.fraction,
{if (!is.null(offset)) offset = grv_yes$offset},
...))
dev.print(file = paste0("./",names(samples[i]),"/pred_dev_bin_simp.jpeg"), device = jpeg, width = 600)
# Add Bin simp stats objects to StatsObjectsList
StatsObjectsList[[length(StatsObjectsList) + 1]] <- Bin_Best_Simp$self.statistics # send to new position after last item
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0(Bin_Best_Model, "_Simp__self.statistics") # name it. new length now includes self.statistics
StatsObjectsList[[length(StatsObjectsList) + 1]] <- Bin_Best_Simp$cv.statistics
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0(Bin_Best_Model, "_Simp__cv.statistics")
} # close if min bin best simp
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Bin model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if ZI
# Same for Gaus
if (gaus) {
Gaus_Best_Simp_Check <- gbm.simplify(get(Gaus_Best_Model))
dev.print(file = paste0("./",names(samples[i]),"/simp_drops_gaus.jpeg"), device = jpeg, width = 600)
if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0) {
assign("Gaus_Best_Simp",
gbm.step.sd(data = grv_yes,
# gbm.x = Gaus_Best_Simp_Check$pred.list[[which.min(Gaus_Best_Simp_Check$deviance.summary$mean)]],
# does the above line return ALL vars or just the simp predictors kept?####
# returns a subsample, but not the same as the one below. In bonnie example, top/original line is:
# 9 19 28 38
# below line is:
# "Latitude" "WTMP"
# code from report Gaus_BRT_simp predictors kept column, can potentially drop in place:
gbm.x = as.character(Gaus_Best_Simp_Check$final.drops$preds[((dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Gaus_Best_Simp_Check$final.drops$preds)]),
# if this works do the same for bin
gbm.y = get(Gaus_Best_Model)$gbm.call$gbm.y,
tree.complexity = get(Gaus_Best_Model)$gbm.call$tree.complexity,
learning.rate = get(Gaus_Best_Model)$gbm.call$learning.rate,
family = get(Gaus_Best_Model)$gbm.call$family,
bag.fraction = get(Gaus_Best_Model)$gbm.call$bag.fraction,
{if (!is.null(offset)) offset = grv_yes$offset},
...))
dev.print(file = paste0("./",names(samples[i]),"/pred_dev_gaus_simp.jpeg"), device = jpeg, width = 600)
# Add Gaus simp stats objects to StatsObjectsList
StatsObjectsList[[length(StatsObjectsList) + 1]] <- Gaus_Best_Simp$self.statistics # send to new position after last item
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0(Gaus_Best_Model, "_Simp__self.statistics") # name it. new length now includes self.statistics
StatsObjectsList[[length(StatsObjectsList) + 1]] <- Gaus_Best_Simp$cv.statistics
names(StatsObjectsList)[[length(StatsObjectsList)]] <- paste0(Gaus_Best_Model, "_Simp__cv.statistics")
} # close if min gaus best simp
if (alerts) beep(2)
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Gaus model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus if
## Select final best models
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI. If Bin_Best has a simplified model:
if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
# & if the simplified model has better correlation than Bin_Best itself
if (Bin_Best_Simp$self.statistics$correlation > Bin_Best_Score[1]) {
# then replace Bin_Best score/model values with those from the simplified model
Bin_Best_Score <- Bin_Best_Simp$self.statistics$correlation
Bin_Best_Name <- paste0(Bin_Best_Model, "_Simp")
Bin_Best_Model <- "Bin_Best_Simp" # assign simp to best
} # close if bin best simp
} # close if min bin best simp
} # close ZI
# Same for Gaus:
if (gaus) {
if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0) {
if (Gaus_Best_Simp$self.statistics$correlation > Gaus_Best_Score[1]) {
Gaus_Best_Score <- Gaus_Best_Simp$self.statistics$correlation
Gaus_Best_Name <- paste0(Gaus_Best_Model, "_Simp")
Gaus_Best_Model <- "Gaus_Best_Simp"
} # close if gaus best
} # close if min gaus best
} # close if gaus
} # close if simp
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Best models selected     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
multiplot
####11. Line plots####
# All plots on one image for Bin & Gaus
if (multiplot) { # don't do if multiplot=FALSE
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
op <- par(oma = c(5,7,1,1)) # younes
par(mar = rep(2, 4)) # for Younes' Error in plot.new() : figure margins too large
png(filename = paste0("./",names(samples[i]),"/Bin_Best_line.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
gbm.plot(get(Bin_Best_Model),
n.plots = length(get(Bin_Best_Model)$contributions$var),
write.title = F, y.label = "Marginal Effect",
plot.layout = c(ceiling(sqrt(length(get(Bin_Best_Model)$contributions$var))),
ifelse(sqrt(length(get(Bin_Best_Model)$contributions$var))
- floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) < 0.5,
floor(sqrt(length(get(Bin_Best_Model)$contributions$var))),
floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) + 1)))
dev.off()
par(op)
} # close ZI     # younes
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/Gaus_Best_line.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
gbm.plot(get(Gaus_Best_Model),
n.plots = length(get(Gaus_Best_Model)$contributions$var),
write.title = F, y.label = "Marginal Effect",
plot.layout = c(ceiling(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
ifelse(sqrt(length(get(Gaus_Best_Model)$contributions$var))
- floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) < 0.5,
floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) + 1)))
dev.off() #close plot device
} # close gaus if
} # close multiplot if
# All plots individually, named by explanatory variable, bin & gaus
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
for (o in 1:length(get(Bin_Best_Model)$contributions$var)) {
png(filename = paste0("./",names(samples[i]),"/Bin_Best_line_",as.character(get(Bin_Best_Model)$gbm.call$predictor.names[o]),".png"),
width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(2.3,5,0.3,0.6), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(1.25,0.5,0), xpd = NA)
gbm.plot(get(Bin_Best_Model),
variable.no = o, # order of variable.no =! order of get(Bin_Best_Model)$contributions$var
n.plots = 1,
common.scale = FALSE, #added to try to get cvs values to match pngs
smooth = smooth,
rug = TRUE,
write.title = FALSE,
y.label = "",
x.label = NULL,
show.contrib = TRUE,
plot.layout = c(1, 1)) # ... for cex.axis, cex.lab etc
mtext("Marginal Effect", side = 2, line = 4.05, las = 0)
# gbm.plot calls plot.gbm ~L47 but then centres to have 0 mean @L53
# Asked Robert Hijmans to add a param to omit this: https://github.com/rspatial/dismo/issues/22
# create lines data to export to file. Need to recreate transformations from gbm.plot
# Next 6 lines from GNG answer https://stats.stackexchange.com/a/144871/43360 which uses gbm.plot code
if (linesfiles) {s <- match(get(Bin_Best_Model)$contributions$var[o],
get(Bin_Best_Model)$gbm.call$predictor.names)
# create dataframe
plotgrid <- plot.gbm(get(Bin_Best_Model), s, return.grid = TRUE)
#If factor variable
if (is.factor(plotgrid[,1])) {
plotgrid[,1] <- factor(plotgrid[,1], levels = levels(get(Bin_Best_Model)$gbm.call$dataframe[,get(Bin_Best_Model)$gbm.call$gbm.x[s]]))
} # close if is factor
# This section centres the values around 0,
# Inverts their position relative to 0 (top becomes bottom),
# Exponentiates them (midrange values push towards extremes)
# Then rescales from 0:1 to +/- values by subtracting the mean from each value
# 2021-10-18 per https://github.com/SimonDedman/gbm.auto/issues/45
# Why I built this code? Copied from https://stats.stackexchange.com/a/144871/43360
# I don't think I need it nor is it helpful. Comment out.
# # replace Y values in place with average-centred values
# plotgrid[,2] <- plotgrid[,2] - mean(plotgrid[,2])
# #Put Y values on a log scale
# plotgrid[,2] <- 1 / (1 + exp(-plotgrid[,2]))
# #Center the response to have zero mean over the data distribution
# plotgrid[,2] <- scale(plotgrid[,2], center = TRUE, scale = FALSE)
# 2023-02-24 this is useful for making ggplots like the plot.gbm
# https://github.com/SimonDedman/gbm.auto/issues/81
plotgrid$ycentred <- plotgrid$y - mean(plotgrid$y)
# write out csv
write.csv(plotgrid, row.names = FALSE, na = "",
file = paste0("./", names(samples[i]), "/Bin_Best_line_",
as.character(get(Bin_Best_Model)$contributions$var[o]),
".csv"))
} #close linesfiles
dev.off()
} # close for o
} # close if fam1 bernoulli / ZI option
if (gaus) {for (p in 1:length(get(Gaus_Best_Model)$contributions$var)) {
png(filename = paste0("./",names(samples[i]),"/Gaus_Best_line_",as.character(get(Gaus_Best_Model)$gbm.call$predictor.names[p]),".png"),
width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(2.3,5,0.3,0.6), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(1.25,0.5,0), xpd = NA)
gbm.plot(get(Gaus_Best_Model),
variable.no = p,
n.plots = 1,
common.scale = FALSE, #added to try to get cvs values to match pngs
smooth = smooth,
rug = TRUE,
write.title = FALSE,
y.label = "",
x.label = NULL,
show.contrib = TRUE,
plot.layout = c(1, 1))
mtext("Marginal Effect", side = 2, line = 4.05, las = 0)
if (linesfiles) {u <- match(get(Gaus_Best_Model)$contributions$var[p],
get(Gaus_Best_Model)$gbm.call$predictor.names)
plotgrid <- plot.gbm(get(Gaus_Best_Model), u, return.grid = TRUE)
if (is.factor(plotgrid[,1])) {
plotgrid[,1] <- factor(plotgrid[,1], levels = levels(get(Gaus_Best_Model)$gbm.call$dataframe[,get(Gaus_Best_Model)$gbm.call$gbm.x[u]]))}
# plotgrid[,2] <- plotgrid[,2] - mean(plotgrid[,2])
# plotgrid[,2] <- 1 / (1 + exp(-plotgrid[,2]))
# plotgrid[,2] <- scale(plotgrid[,2], scale = FALSE)
plotgrid$ycentred <- plotgrid$y - mean(plotgrid$y)
write.csv(plotgrid, row.names = FALSE, na = "",
file = paste0("./", names(samples[i]), "/Gaus_Best_line_",
as.character(get(Gaus_Best_Model)$contributions$var[p]),
".csv"))} #close linesfiles
dev.off() }} # close if gaus
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Line plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####12. Dot plots####
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
png(filename = paste0("./",names(samples[i]),"/Bin_Best_dot.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
gbm.plot.fits(get(Bin_Best_Model))
dev.off()} # close ZI
if (gaus) {png(filename = paste0("./",names(samples[i]),"/Gaus_Best_dot.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
gbm.plot.fits(get(Gaus_Best_Model))
dev.off()} # close if gaus
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Dot plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####14. Bar plots of variable influence####
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # create tables
Bin_Bars <- summary(get(Bin_Best_Model),
cBars = length(get(Bin_Best_Model)$var.names),
n.trees = get(Bin_Best_Model)$n.trees,
plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
write.csv(Bin_Bars, file = paste0("./", names(samples[i]), "/Binary BRT Variable contributions.csv"), row.names = FALSE)} # close ZI
if (gaus) {Gaus_Bars <- summary(get(Gaus_Best_Model),
cBars = length(get(Gaus_Best_Model)$var.names),
n.trees = get(Gaus_Best_Model)$n.trees,
plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
write.csv(Gaus_Bars, file = paste0("./", names(samples[i]), "/Gaussian BRT Variable contributions.csv"), row.names = FALSE)} # close if gaus
if (alerts) beep(2)# progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Bar plot csvs created    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # produce graphics
pointlineseqbin <- seq(0, length(Bin_Bars[,2]) - 1, 1)
png(filename = paste0("./",names(samples[i]),"/Bin_Bars.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
type = pngtype)
par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.5, mgp = c(1.5,0.5,0), cex = 1.3, lwd = 6)
barplot(rev(Bin_Bars[,2]), cex.lab = 1.2, las = 1, # axis labs horizontal
horiz = TRUE, # make horizontal
xlab = "Relative Influence %", col = NA, border = NA, # no border, lwd redundant
xlim = c(0, 2.5 + ceiling(max(Bin_Bars[,2]))),
ylim = c(0, length(Bin_Bars[,2])), # figure height as a proportion of nBars
beside = T) # juxtaposed not stacked
#points(rev(Bin_Bars[,2]), pointlineseqbin, pch = 20, cex = 1.75, col = "black") #black dots at line ends
revseq <- rev(pointlineseqbin)
for (q in 1:length(Bin_Bars[,2])) {
lines(c(0, Bin_Bars[q,2]), c(revseq[q], revseq[q]), col = "black", lwd = 8)}
text(0.1, pointlineseqbin + (length(Bin_Bars[,2])/55), labels = rev(Bin_Bars[,1]), adj = 0, cex = 0.8)
axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
dev.off()} # close ZI
if (gaus) {
pointlineseqgaus <- seq(0, length(Gaus_Bars[,2]) - 1, 1)
png(filename = paste0("./",names(samples[i]),"/Gaus_Bars.png"),
width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
type = pngtype)
par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.5, mgp = c(1.5,0.5,0), cex = 1.3, lwd = 6)
barplot(rev(Gaus_Bars[,2]), cex.lab = 1.2, las = 1, # axis labs horizontal
horiz = TRUE, # make horizontal
xlab = "Relative Influence %", col = NA, border = NA, # no border, lwd redundant
xlim = c(0, 2.5 + ceiling(max(Gaus_Bars[,2]))),
ylim = c(0, length(Gaus_Bars[,2])), # figure height as a proportion of nBars
beside = T) # juxtaposed not stacked
#points(rev(Gaus_Bars[,2]), pointlineseqgaus, pch = 20, cex = 1.75, col = "black")
revseq <- rev(pointlineseqgaus)
for (r in 1:length(Gaus_Bars[,2])) {
lines(c(0, Gaus_Bars[r,2]), c(revseq[r], revseq[r]), col = "black", lwd = 8)
} # close for r
text(0.1, pointlineseqgaus + (length(Gaus_Bars[,2])/55), labels = rev(Gaus_Bars[,1]), adj = 0, cex = 0.8)
axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
dev.off() #close PNG
} # close if gaus
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Bar plots plotted      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####15. Variable interactions####
if (varint) {
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) find.int_Bin <- gbm.interactions(get(Bin_Best_Model))
if (gaus) find.int_Gaus <- gbm.interactions(get(Gaus_Best_Model))
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Variable interactions done XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close varint if
####16. Save model objects####
if (savegbm) { # Save model objects if switched on
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
Bin_Best_Model_Object <- get(Bin_Best_Model)
# Bin_Best_Model <<- Bin_Best_Model_Object # this causes Bin_Best_Model to BE the model not the name of the original
} # close if ZI
if (gaus) {
Gaus_Best_Model_Object <- get(Gaus_Best_Model)
# Gaus_Best_Model <<- Gaus_Best_Model_Object
save(Gaus_Best_Model_Object, file = paste0("./",names(samples[i]),"/Gaus_Best_Model"))
} # close if gaus
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
save(Bin_Best_Model_Object, file = paste0("./",names(samples[i]),"/Bin_Best_Model")) #only save bin if ZI=TRUE
} # close if ZI
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Model objects saved     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if savegbm
####17. Finalise & Write Report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) { # only do bin bits if ZI; move 7 cols left if no gaus run
# L812, 873, 879: ZI yes, gaus ifelse sections, should combine####
if (gaus) {
Report[1:15,(reportcolno - 13)] <- c(paste0("Model combo: ", Bin_Best_Name),
paste0("trees: ", get(Bin_Best_Model)$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Score, 3)),
paste0("Training data AUC score: ", round(get(Bin_Best_Model)$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(get(Bin_Best_Model)$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(get(Bin_Best_Model)$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(get(Bin_Best_Model)$self.statistics$discrimination - get(Bin_Best_Model)$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(get(Bin_Best_Model)$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(get(Bin_Best_Model)$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(get(Bin_Best_Model)$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(get(Bin_Best_Model)$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(get(Bin_Best_Model)$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(get(Bin_Best_Model)$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((get(Bin_Best_Model)$self.statistics$mean.null - get(Bin_Best_Model)$self.statistics$mean.resid) / get(Bin_Best_Model)$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((get(Bin_Best_Model)$self.statistics$mean.null - get(Bin_Best_Model)$cv.statistics$deviance.mean) / get(Bin_Best_Model)$self.statistics$mean.null)*100, 2)))
} else {
Report[1:15,(reportcolno - 6)] <- c(paste0("Model combo: ", Bin_Best_Name),
paste0("trees: ", get(Bin_Best_Model)$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Score, 3)),
paste0("Training data AUC score: ", round(get(Bin_Best_Model)$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(get(Bin_Best_Model)$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(get(Bin_Best_Model)$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(get(Bin_Best_Model)$self.statistics$discrimination - get(Bin_Best_Model)$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(get(Bin_Best_Model)$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(get(Bin_Best_Model)$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(get(Bin_Best_Model)$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(get(Bin_Best_Model)$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(get(Bin_Best_Model)$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(get(Bin_Best_Model)$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((get(Bin_Best_Model)$self.statistics$mean.null - get(Bin_Best_Model)$self.statistics$mean.resid) / get(Bin_Best_Model)$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((get(Bin_Best_Model)$self.statistics$mean.null - get(Bin_Best_Model)$cv.statistics$deviance.mean) / get(Bin_Best_Model)$self.statistics$mean.null)*100, 2)))
} # close if else gaus bin report
if (simp) { # bin & gaus simp stats (or no simp notes)
if (gaus) {
Report[1:dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1], (reportcolno - 12)] <- as.character(subset(Bin_Best_Simp_Check$final.drops, order > 0)$preds)
# listing simp predictors kept: rows 1 to 'howevermany are left in simp' i.e. above 0
# [1] is the first item of the dim list of rows & columns, i.e. rows
Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 11)] <-
as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])
# listing simp predictors dropped.
if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:14,(reportcolno - 10)] <- c(paste0("trees: ", Bin_Best_Simp$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Simp$self.statistics$correlation[[1]], 3)),
paste0("Training data AUC score: ", round(Bin_Best_Simp$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(Bin_Best_Simp$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(Bin_Best_Simp$self.statistics$discrimination - Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(Bin_Best_Simp$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(Bin_Best_Simp$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(Bin_Best_Simp$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(Bin_Best_Simp$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(Bin_Best_Simp$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(Bin_Best_Simp$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$self.statistics$mean.resid) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$cv.statistics$deviance.mean) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # if min
Report[1,(reportcolno - 10)] <- paste0("No simplification benefit")
} # close if min else
} else { # bin predictors etc
Report[1:dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1], (reportcolno - 5)] <- as.character(subset(Bin_Best_Simp_Check$final.drops, order > 0)$preds)
Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 4)] <-
as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])
if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:14,(reportcolno - 3)] <- c(paste0("trees: ", Bin_Best_Simp$n.trees),
paste0("Training Data Correlation: ", round(Bin_Best_Simp$self.statistics$correlation[[1]], 3)),
paste0("Training data AUC score: ", round(Bin_Best_Simp$self.statistics$discrimination, 3)),
paste0("CV AUC score: ", round(Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV AUC se: ", round(Bin_Best_Simp$cv.statistics$discrimination.se, 3)),
paste0("Overfitting (Training data AUC - CV AUC): ", round(Bin_Best_Simp$self.statistics$discrimination - Bin_Best_Simp$cv.statistics$discrimination.mean, 3)),
paste0("CV Mean Deviance: ", round(Bin_Best_Simp$cv.statistics$deviance.mean, 3)),
paste0("CV Deviance SE: ", round(Bin_Best_Simp$cv.statistics$deviance.se, 3)),
paste0("CV D squared: ", round(Bin_Best_Simp$cv.statistics$d.squared, 3)),
paste0("CV Mean Correlation: ", round(Bin_Best_Simp$cv.statistics$correlation.mean, 3)),
paste0("CV Correlation SE: ", round(Bin_Best_Simp$cv.statistics$correlation.se, 3)),
paste0("CV RMSE: ", round(Bin_Best_Simp$cv.statistics$cv.rmse, 3)),
paste0("Deviance% explained relative to null, training: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$self.statistics$mean.resid) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)),
paste0("Deviance% explained relative to null, CV: ", round(((Bin_Best_Simp$self.statistics$mean.null - Bin_Best_Simp$cv.statistics$deviance.mean) / Bin_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # if min bin best simp
Report[1,(reportcolno - 3)] <- paste0("No simplification benefit")
} # close if min bin best simp else
} # close bin half of bin/gaus option. Next line is 2nd half of simp option i.e. not simplified
} else if (gaus) { # if not simp but is gaus
Report[1,(reportcolno - 12):(reportcolno - 10)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} else {# not gaus not simp: report cols are changed so needs adjustment
Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} # close 2nd half of simp else, i.e. nosimp bin. Closes bin & gaus simp stats (or no simp notes)
if (gaus) { # if zi & gaus again, second section
Report[1:(length(Bin_Bars[,1])),(reportcolno - 9)] <- as.character(Bin_Bars$var)
} else { # if zi & bin only
Report[1:(length(Bin_Bars[,1])),(reportcolno - 2)] <- as.character(Bin_Bars$var)
} # close ifelse best bin variables rel inf names ordered
if (gaus) { # if ZI & gaus again
Report[1:(length(Bin_Bars[,2])),(reportcolno - 8)] <- as.character(round(Bin_Bars$rel.inf), 2)
} else { # zi & not gaus
Report[1:(length(Bin_Bars[,2])),(reportcolno - 1)] <- as.character(round(Bin_Bars$rel.inf), 2)
} # close ifelse best bin variables rel inf scores
if (varint) { # only do final variable interaction lines if varint=TRUE
if (gaus) { # varint gaus
# Report[1:2,(reportcolno - 7)] <- c(paste0(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1]),
#                                    paste0(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2]))
# 2020-12-17 update, see below
for (v in 1:min(length(which(find.int_Bin$rank.list$int.size > 0)),
nrow(Report))) {
Report[v, (reportcolno - 7)] <- paste0(find.int_Bin$rank.list$var1.names[v]," and ",find.int_Bin$rank.list$var2.names[v],". Size: ",find.int_Bin$rank.list$int.size[v])
}
} else { # varint yes gaus no
# Report[1:2,(reportcolno)] <- c(paste0(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1]),
#                                paste0(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2]))
# 2020-12-17 update, see below
for (u in 1:min(length(which(find.int_Bin$rank.list$int.size > 0)),
nrow(Report))) {
Report[u, (reportcolno)] <- paste0(find.int_Bin$rank.list$var1.names[u]," and ",find.int_Bin$rank.list$var2.names[u],". Size: ",find.int_Bin$rank.list$int.size[u])
}
} # close varint yes gaus no
} else { # varint no
if (gaus) { # varint no gaus yes
Report[1,(reportcolno - 7)] <- paste0("varint turned off")
} else { # varint no gaus no
Report[1,(reportcolno)] <- paste0("varint turned off")
} # close not varint not gaus
} # close not varint
} # close ZI way further up start of report section (L810)
if (gaus) {
Report[1:11 ,(reportcolno - 6)] <- c(paste0("Model combo: ", Gaus_Best_Name),
paste0("trees: ", get(Gaus_Best_Model)$n.trees),  # new, might not work
paste0("Training Data Correlation: ", round(Gaus_Best_Score, 3)),
paste0("CV Mean Deviance: ", round(get(Gaus_Best_Model)$cv.statistics$deviance.mean, 3)), # new, might not work
paste0("CV Deviance SE: ", round(get(Gaus_Best_Model)$cv.statistics$deviance.se, 3)), # new, might not work
paste0("CV D squared: ", round(get(Gaus_Best_Model)$cv.statistics$d.squared, 3)), # new, might not work
paste0("CV Mean Correlation: ", round(get(Gaus_Best_Model)$cv.statistics$correlation.mean, 3)), # new, might not work
paste0("CV Correlation SE: ", round(get(Gaus_Best_Model)$cv.statistics$correlation.se, 3)), # new, might not work
paste0("CV RMSE: ", round(get(Gaus_Best_Model)$cv.statistics$cv.rmse, 3)), # new, might not work
paste0("Deviance% explained relative to null, training: ", round(((get(Gaus_Best_Model)$self.statistics$mean.null - get(Gaus_Best_Model)$self.statistics$mean.resid) / get(Gaus_Best_Model)$self.statistics$mean.null)*100, 2)), # new, might not work
paste0("Deviance% explained relative to null, CV: ", round(((get(Gaus_Best_Model)$self.statistics$mean.null - get(Gaus_Best_Model)$cv.statistics$deviance.mean) / get(Gaus_Best_Model)$self.statistics$mean.null)*100, 2))) # new, might not work
if (simp) {
Report[1:dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 5)] <- as.character(subset(Gaus_Best_Simp_Check$final.drops ,order > 0)$preds)
Report[1:(length(Gaus_Best_Simp_Check$final.drops$preds) - dim(subset(Gaus_Best_Simp_Check$final.drops, order > 0))[1]), (reportcolno - 4)] <-
as.character(Gaus_Best_Simp_Check$final.drops$preds[((dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Gaus_Best_Simp_Check$final.drops$preds)])
if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0) {
Report[1:10, (reportcolno - 3)] <- c(paste0("trees: ", Gaus_Best_Simp$n.trees),
paste0("Training Data Correlation: ", Gaus_Best_Simp$self.statistics$correlation[[1]]),
paste0("CV Mean Deviance: ", Gaus_Best_Simp$cv.statistics$deviance.mean),
paste0("CV Deviance SE: ", Gaus_Best_Simp$cv.statistics$deviance.se),
paste0("CV D squared: ", Gaus_Best_Simp$cv.statistics$d.squared),
paste0("CV Mean Correlation: ", Gaus_Best_Simp$cv.statistics$correlation.mean),
paste0("CV Correlation SE: ", Gaus_Best_Simp$cv.statistics$correlation.se),
paste0("CV RMSE: ", Gaus_Best_Simp$cv.statistics$cv.rmse),
paste0("Deviance% explained relative to null, training: ", round(((Gaus_Best_Simp$self.statistics$mean.null - Gaus_Best_Simp$self.statistics$mean.resid) / Gaus_Best_Simp$self.statistics$mean.null)*100, 2)), # new, might not work
paste0("Deviance% explained relative to null, CV: ", round(((Gaus_Best_Simp$self.statistics$mean.null - Gaus_Best_Simp$cv.statistics$deviance.mean) / Gaus_Best_Simp$self.statistics$mean.null)*100, 2)))
} else { # else if min gaus best simp, stats where simp benefit true, open note where no simp benefit
Report[1,(reportcolno - 3)] <- paste0("No simplification benefit")
} # close if else simp benefit check
} else { # close gaus yes simp yes, do gaus yes simp no
Report[1,(reportcolno - 5):(reportcolno - 3)] <- c(paste0("simp turned off"),
paste0("simp turned off"),
paste0("simp turned off"))
} # close simp, still in gaus yes
Report[1:(length(Gaus_Bars[,1])),(reportcolno - 2)] <- as.character(Gaus_Bars$var)
Report[1:(length(Gaus_Bars[,2])),(reportcolno - 1)] <- as.character(round(Gaus_Bars$rel.inf), 2)
if (varint) { # gaus yes varint yes
# 2020.12.17 instead of top 2 interactions, do all of them that are > 0 size (unless there are more than the report nrow)
for (t in 1:min(length(which(find.int_Gaus$rank.list$int.size > 0)),
nrow(Report))) {
Report[t, (reportcolno)] <- paste0(find.int_Gaus$rank.list$var1.names[t]," and ",find.int_Gaus$rank.list$var2.names[t],". Size: ",find.int_Gaus$rank.list$int.size[t])
}
# Report[1:2,(reportcolno)] <- c(paste0(find.int_Gaus$rank.list$var1.names[1]," and ",find.int_Gaus$rank.list$var2.names[1],". Size: ",find.int_Gaus$rank.list$int.size[1]),
#                                paste0(find.int_Gaus$rank.list$var1.names[2]," and ",find.int_Gaus$rank.list$var2.names[2],". Size: ",find.int_Gaus$rank.list$int.size[2]))
} else { # gaus yes varint no
Report[1,(reportcolno)] <- paste0("varint turned off")
} # close varint yes no, still in gaus yes
} # close gaus if
View(Report)
tmp <- Report
tmp[, "Buttholes"] <- c(1,2,3,4)
tmp[, "Buttholes"] <- as.character(NA)
View(tmp)
tmp <- Report
tmp[, "Metadata"] <- as.character(NA)
View(tmp)
tmp$Metadata[1:4]
samples[i]
i
length(samples[i])
i
samples[, i]
length(samples[, i])
names(samples[i])
grv_yes[, i]
length(grv_yes[, i])
tmp$Metadata[1:4] <- c(
paste0("gbm.auto v", packageVersion("gbm.auto")),
paste0("dismo v", packageVersion("dismo")),
paste0("fam1 n ", length(samples[, i])),
ifelse(gaus, paste0("fam2 n ", length(grv_yes[, i])), as.character(NA))
)
Report[, "Metadata"] <- as.character(NA)
Report$Metadata[1:4] <- c(
paste0("gbm.auto v", packageVersion("gbm.auto")),
paste0("dismo v", packageVersion("dismo")),
paste0("fam1 n ", length(samples[, i])),
ifelse(gaus, paste0("fam2 n ", length(grv_yes[, i])), as.character(NA))
)
write.csv(Report, row.names = FALSE, na = "", file = paste0("./", names(samples[i]), "/Report.csv"))
sum(samples[,i] == 0, na.rm = TRUE)
sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i])
round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3)
paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100)
paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes")
Report[1,3]
Report[2,3]
Report[2,3] <- paste0(round(sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]), 3) * 100, "% zeroes")
Report[2,3]
library(devtools)
document()
build()
