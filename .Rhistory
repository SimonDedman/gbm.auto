#                    e@MCR[which.max(e@TPR + e@TNR)])
#   # e@OR: Odds-ratio
#   MLEval[29,] <- c("OR",
#                    "Odds-ratio",
#                    e@OR[which.max(e@TPR + e@TNR)])
#   # e@kappa: Cohen's kappa
#   MLEval[30,] <- c("kappa",
#                    "Cohen's kappa",
#                    e@kappa[which.max(e@TPR + e@TNR)])
#   # dev from calc.deviance from dismo
#   MLEval[31,] <- c("dev",
#                    "deviance from 2 vecs, obs & pred vals",
#                    dev)
#
#   # MLEval$Value <- round(MLEval$Value, digits = 5)
#   write.csv(MLEval, row.names = FALSE, na = "", file = paste0("./", names(samples[i]), "/MLEvalMetricsGaus.csv"))
#
#   evalmetrics <- c("ROC", "kappa", "prevalence", "TPR", "TNR", "FPR", "FNR", "CCR", "PPP", "NPP", "MCR", "OR")
#   for (s in evalmetrics) {
#     png(filename = paste0("./",names(samples[i]),"/Gaus_Eval_", s, ".png"))
#     plot(e, s)
#     dev.off()
#   } # close for (s in evalmetrics)
# } # close if (gaus)
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXX     Evaluation Metrics Processed     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if MLEvaluate
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Report CSV written      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close loadgbm isnull
#avoid sections 19-25 if not predicting to grids
if (!is.null(grids)) {
# Load model objects if loadgbm set
if (!is.null(loadgbm)) {
if (fam1 == "bernoulli" & (gaus == FALSE | (gaus == TRUE & ZI == TRUE))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
load(paste0(loadgbm, "Bin_Best_Model"))
Bin_Best_Model <- "Bin_Best_Model_Object"
} # close ZI if
if (gaus) {
load(paste0(loadgbm, "Gaus_Best_Model"))
Gaus_Best_Model <- "Gaus_Best_Model_Object"
} # close gaus if
dir.create(names(samples[i])) # create resvar-named directory for outputs
} # close if isnull loadgbm
####19. Binomial predictions####
if (fam1 == "bernoulli" & (gaus == FALSE | (gaus == TRUE & ZI == TRUE))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
gbm.predict.grids(get(Bin_Best_Model), grids, want.grids = F, sp.name = "Bin_Preds") #with want.grids=F this is just predict.gbm
grids$Bin_Preds <- Bin_Preds
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Binomial predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if ZI
####20. Gaussian predictions####
if (gaus) {
gbm.predict.grids(get(Gaus_Best_Model), grids, want.grids = F, sp.name = "Gaus_Preds")
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Gaussian predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
if (fam1 == "bernoulli" & (gaus == FALSE | (gaus == TRUE & ZI == TRUE))) {
grids$Gaus_Preds <- Gaus_Preds
####21. Backtransform logged Gaus to unlogged####
grids$Gaus_Preds_Unlog <- exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
####22. BIN*positive abundance = final abundance####
grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds
} else { # close gaus yes zi yes run gaus yes zi no
grids$PredAbund <- Gaus_Preds #if ZI=TRUE, unlog gaus & multiply by bin. Else just use gaus preds.
} # close ifelse zi
} else { # if not gaus
grids$PredAbund <- grids$Bin_Preds # if only doing Bin, preds are just bin preds
} # close ifelse gaus
predabund <- which(colnames(grids) == "PredAbund") # predicted abundance column number for writecsv
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Final abundance calculated  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####23. Final saves####
# CSV of Predicted values at each site inc predictor variables' values.
write.csv(grids, row.names = FALSE, file = paste0("./", names(samples[i]), "/Abundance_Preds_All.csv"))
# CSV of Predicted values at each site without predictor variables' values.
# coerce character gridslat/lon into numeric since predabund is given as numeric & you can't mix
if (is.character(gridslat)) gridslat <- which(colnames(samples) == gridslat)
if (is.character(gridslon)) gridslon <- which(colnames(samples) == gridslon)
write.csv(grids[c(gridslat,gridslon,predabund)], row.names = FALSE, file = paste0("./", names(samples[i]), "/Abundance_Preds_only.csv"))
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Output CSVs written     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####24. Unrepresentativeness surface builder####
# builds doesn't plot surface. If built, plotted by map maker.
if (RSB) {
rsbdf_bin <- gbm.rsb(samples, grids, expvarnames, gridslat, gridslon)
pos_samples <- subset(samples, brv > 0)
if (gaus) {
rsbdf_gaus <- gbm.rsb(pos_samples, grids, expvarnames, gridslat, gridslon)
rsbdf_both <- data.frame(rsbdf_bin, "Unrep_Gaus" = rsbdf_gaus[,"Unrepresentativeness"], "Unrep_Both" = (rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"]))
write.csv(rsbdf_both, row.names = FALSE, file = paste0("./", names(samples[i]), "/RSB.csv"))
} else { # not gaus
write.csv(rsbdf_bin, row.names = FALSE, file = paste0("./", names(samples[i]), "/RSB.csv")) # if not gaus
} # close if else gaus
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       RSB CSV written       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if RSB
####25. Map maker####
if (map) {   # generate output image & set parameters
png(filename = paste0("./",names(samples[i]),"/PredAbundMap_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
# run gbm.map function with generated parameters
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = grids[,predabund],
species = names(samples[i]),
shape = shape, #either autogenerated or set by user so never blank
...)  # allows gbm.auto's optional terms to be passed to subfunctions:
# byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Reticulating splines     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Colour map generated     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
if (BnW) { # if BnW=TRUE, run again in black & white for journal submission
png(filename = paste0("./",names(samples[i]),"/PredAbundMap_BnW_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = grids[,predabund],
species = names(samples[i]),
shape = shape, #either autogenerated or set by user so never blank
landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
mapback = "white",
heatcolours = grey.colors(8, start = 1, end = 0),
...)  # allows gbm.auto's optional terms to be passed to subfunctions:
# byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
dev.off()
if (alerts) beep(2)  # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Black & white map generated XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close & save plotting device & close BnW optional
if (RSB) { # if RSB called, plot that surface separately
linear01seq <- seq(from = 0, to = 1, length.out = 9) #linear sequence from 0:1, 9 bins
exp01seq <- expm1(4*linear01seq)/expm1(4) # exponentiate to change shape then scale back to 1
if (fam1 == "bernoulli" & (gaus == FALSE | (gaus == TRUE & ZI == TRUE))) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Bin_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
# breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = TRUE))/2000) #old failing breaks
breaks = exp01seq)
dev.off() #high value log breaks mean first ~5 values cluster near 0 for high
# res there, but high values captures in the last few bins.
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Colour RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if zi bin
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Gaus_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus map
if (ZI & gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Both_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-2",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close both map
if (BnW) {     # if BnW=TRUE, do again for b&w
if (fam1 == "bernoulli" & (gaus == FALSE | (gaus == TRUE & ZI == TRUE))) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Bin_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0), #default 8 greys
####BUG:setting heatcolours & colournumber overrides this####
landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     B&W RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close bin RSB
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Gaus_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus RSB
if (ZI & gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Both_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-2",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus (&combo) B&W RSB
} # close BnW RSBs
} # close RSB mapper
} # close Map Maker
} #close !isnull grids option from above section 19
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Grids/maps/everything done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close for i in resvar response variable loop
gc() # Force R to release memory it is no longer using
options(error = NULL) # reset error options to default
if (alerts) beep(8)  # final user notification, then close the function
}
gbm.auto(grids = grids, samples = samples, expvar = c(4:8, 10), resvar = 11,
tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.rsb.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.utils.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
gbm.auto(grids = grids, samples = samples, expvar = c(4:8, 10), resvar = 11,
tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
traceback()
options(error = browser())
gbm.auto(grids = grids, samples = samples, expvar = c(4:8, 10), resvar = 11,
tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
gbm.auto(grids = grids, samples = samples, expvar = c(4:8, 10), resvar = 11,
tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop")
dir.create("gbmauto")
setwd("gbmauto")
gbm.auto(grids = grids, samples = samples, expvar = c(4:8, 10), resvar = 11,
tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE)
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto")
data(grids)
data(samples)
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE)
Gaus_Preds
View(grids)
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
rm(Gaus_Preds)
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.utils.R')
gbm.predict.grids(model = get(Gaus_Best_Model),new.dat = grids,want.grids = F,sp.name = "Gaus_Preds")
get(Gaus_Best_Model)
debugSource('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.utils.R')
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE)
Gaus_Preds
gbm.predict.grids(get(Gaus_Best_Model), grids, want.grids = F, sp.name = "Gaus_Preds")
View(plotgrid)
debugSource('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE)
debugSource('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
install_github("SimonDedman/gbm.auto")
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
gbm.auto
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
tmp <- 1
getwd()
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
tmp<-1
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
gbm.predict.grids <- function(model, new.dat, want.grids = F, preds2R = T, sp.name = "preds", pred.vec = NULL, filepath = NULL,
num.col = NULL, num.row = NULL, xll = NULL, yll = NULL, cell.size = NULL, no.data = NULL, plot = F,
full.grid = T, part.number = NULL, part.row = NULL, header = T)
{
# J.Elith / J.Leathwick, March 07
# to make predictions to sites or grids. If to sites, the predictions are written to the R workspace. If to grid,
# the grids are written to a nominated directory and optionally also plotted in R
#
# new data (new.dat) must be a data frame with column names identical to names for all variables in the model used for prediction.
# pred.vec is a vector of -9999's, the length of the scanned full grid (i.e. without nodata values excluded).
# filepath must specify the whole path as a character vector,but without the final file name - eg "c:/gbm/"
temp <- predict.gbm(model, new.dat, n.trees = model$gbm.call$best.trees, type = "response")
if (want.grids) {
newname <- paste0(filepath, sp.name,".asc")
full.pred <- pred.vec
full.pred[as.numeric(row.names(new.dat))] <- temp
if (header) {
write(paste0("ncols          ",num.col),newname)
write(paste0("nrows          ",num.row),newname,append = T)
write(paste0("xllcorner      ",xll),newname,append = T)
write(paste0("yllcorner      ",yll),newname,append = T)
write(paste0("cellsize       ",cell.size),newname,append = T)
write(paste0("NODATA_value ",no.data),newname,append = T)
}
if (full.grid) {
full.pred.mat <- matrix(full.pred, nrow = num.row, ncol = num.col, byrow = T)
if (plot) {image(z = t(full.pred.mat)[, nrow(full.pred.mat):1], zlim =  c(0,1), col = rev(topo.colors(12)))}
write.table(full.pred.mat, newname, sep = " ", append = T, row.names = F, col.names = F)
#also write to R directory, if required:
if (preds2R) {assign(sp.name, temp, pos = 1)}
} else {
full.pred.mat <- matrix(full.pred, nrow = part.row, ncol = num.col, byrow = T)
write.table(full.pred.mat, newname, sep = " ", append = T, row.names = F, col.names = F)
if (preds2R) {assign(paste0(sp.name, part.number), temp, pos = 1)}
}
} else {
assign(sp.name, temp, pos = 1)
}
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
Gaus_Preds <- gbm.predict.grids(model = get(Gaus_Best_Model),
new.dat = grids,
want.grids = F,
sp.name = "Gaus_Preds")
Gaus_Preds
grids$Gaus_Preds <- Gaus_Preds
exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
grids$Gaus_Preds_Unlog <- exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds
Bin_Preds
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
gbm.auto
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
gbm.auto
library(gbm.auto)
gbm.auto
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
check()
library(devtools)
check()
library(gbm.auto)
library(devtools)
