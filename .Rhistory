heatcolours = grey.colors(8, start = 1, end = 0), #default 8 greys
####BUG:setting heatcolours & colournumber overrides this####
landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     B&W RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close bin RSB
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Gaus_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus RSB
if (ZI & gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Both_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-2",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus (&combo) B&W RSB
} # close BnW RSBs
} # close RSB mapper
} # close Map Maker
} #close !isnull grids option from above section 19
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Grids/maps/everything done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close for i in resvar response variable loop
devtools::document()
document()
library(devtools)
document()
library(devtools)
document()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/")
library(tidyverse)
library(MASS)
library(vegan)
library(reshape)
library(doBy)
library(utils)
library(RcmdrMisc)
library(ResourceSelection)
library(boot)
library(ggplot2)
library(gplots)
library(rstatix)
library(dismo)
# library(ggBRT)
library(ape)
library(gbm)
library(remotes)
remotes::install_github("SimonDedman/gbm.auto", force = TRUE)
library(gbm.auto)
wide.df1 <- data.frame(read.csv("wide.df1.ch3.2022.11.csv", header = TRUE, as.is = TRUE)) # importing CSV#
wide.df1$geo <- as.factor(wide.df1$geo)
wide.df1$isl_grp <- as.factor(wide.df1$isl_grp)
wide.df1$archi <- as.factor(wide.df1$archi)
wide.df1$Season <- as.factor(wide.df1$Season)
wide.df1$bait_type <- as.factor(wide.df1$bait_type)
wide.df1$topo <- as.factor(wide.df1$topo)
wide.df1$log_vid_length <- log(wide.df1$vid_length)
gbm.auto(
grids = NULL,
samples = wide.df1,
expvar = c("ave_temp",
"ave_npp",
"depth",
"visibility",
"topo",
"grav",
"bait_type",
"time.no.bait",
"isl_grp",
"Season",
"lagoon.size"), # fix to final variables
resvar = "nspp_elasmo",
tc = c(5), # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do
lr = c(0.01),
bf = c(0.60),
ZI = FALSE,
fam1 = c("poisson"),
fam2 = c("poisson"), #
simp = FALSE, # Change to true
gridslat = 2,
gridslon = 1,
multiplot = TRUE,
cols = grey.colors(1, 1, 1),
linesfiles = TRUE, # change to true for final run
smooth = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/",
savegbm = TRUE, # change to true for final runs
loadgbm = NULL,
varint = TRUE,
map = TRUE,
shape = NULL,
RSB = TRUE,
BnW = TRUE,
alerts = TRUE, # this is the noise alerts
pngtype = c("quartz"), # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE,
MLEvaluate = TRUE,
brv = NULL,
grv = NULL,
Bin_Preds = NULL,
Gaus_Preds = NULL,
offset = wide.df1$log_vid_length
)
gbm.auto(
grids = NULL,
samples = wide.df1,
expvar = c("ave_temp",
"ave_npp",
"depth",
"visibility",
"topo",
"grav",
"bait_type",
"time.no.bait",
"isl_grp",
"Season",
"lagoon.size"), # fix to final variables
resvar = "nspp_elasmo",
tc = c(5), # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do
lr = c(0.01),
bf = c(0.60),
ZI = FALSE,
fam1 = c("poisson"),
fam2 = c("poisson"), #
simp = FALSE, # Change to true
gridslat = 2,
gridslon = 1,
multiplot = TRUE,
cols = grey.colors(1, 1, 1),
linesfiles = TRUE, # change to true for final run
smooth = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/",
savegbm = TRUE, # change to true for final runs
loadgbm = NULL,
varint = TRUE,
map = TRUE,
shape = NULL,
RSB = TRUE,
BnW = TRUE,
alerts = TRUE, # this is the noise alerts
# pngtype = c("quartz"), # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE,
MLEvaluate = TRUE,
brv = NULL,
grv = NULL,
Bin_Preds = NULL,
Gaus_Preds = NULL,
offset = wide.df1$log_vid_length
)
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/")
library(tidyverse)
library(MASS)
library(vegan)
library(reshape)
library(doBy)
library(utils)
library(RcmdrMisc)
library(ResourceSelection)
library(boot)
library(ggplot2)
library(gplots)
library(rstatix)
library(dismo)
# library(ggBRT)
library(ape)
library(gbm)
library(gbm.auto)
#library(remotes)
#remotes::install_github("SimonDedman/gbm.auto", force = TRUE)
#import dataframe #
wide.df1 <- data.frame(read.csv("wide.df1.ch3.2022.11.csv", header = TRUE, as.is = TRUE)) # importing CSV#
wide.df1$geo <- as.factor(wide.df1$geo)
wide.df1$isl_grp <- as.factor(wide.df1$isl_grp)
wide.df1$archi <- as.factor(wide.df1$archi)
wide.df1$Season <- as.factor(wide.df1$Season)
wide.df1$bait_type <- as.factor(wide.df1$bait_type)
wide.df1$topo <- as.factor(wide.df1$topo)
wide.df1$log_vid_length <- log(wide.df1$vid_length)
### BRT N Spp ##
grids = NULL
samples = wide.df1
expvar = c("ave_temp",
"ave_npp",
"depth",
"visibility",
"topo",
"grav",
"bait_type",
"time.no.bait",
"isl_grp",
"Season",
"lagoon.size") # fix to final variables
resvar = "nspp_shark"
tc = c(5) # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do
lr = c(0.01)
bf = c(0.60)
n.trees = 50
ZI = FALSE
fam1 = c("poisson")
fam2 = c("poisson") # was poisson
# fam2 = "gaussian" # not run anyway
simp = FALSE # Change to true
gridslat = 2
gridslon = 1
multiplot = TRUE
cols = grey.colors(1, 1, 1)
linesfiles = TRUE # change to true for final run
smooth = TRUE
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/"
savegbm = TRUE # change to true for final runs
loadgbm = NULL
varint = TRUE
map = TRUE
shape = NULL
RSB = TRUE
BnW = TRUE
alerts = TRUE # this is the noise alerts
pngtype = c("quartz") # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE
# gaus = FALSE # was TRUE
MLEvaluate = TRUE
brv = NULL
grv = NULL
Bin_Preds = NULL
Gaus_Preds = NULL
offset = "log_vid_length"
library(beepr)
library(dplyr)
oldpar <- par(no.readonly = TRUE) # defensive block, thanks to Gregor Sayer
oldwd <- getwd()
oldoptions <- options()
on.exit(par(oldpar))
on.exit(setwd(oldwd), add = TRUE)
on.exit(options(oldoptions), add = TRUE)
setwd(savedir)
if (alerts) options(error = function() {
beep(9)# give warning noise if it fails
graphics.off()# kill all graphics devices
setwd(oldwd) # reinstate original working directory. Probably redundant given on.exit
} # close options subcurly
) # close options
if (fam1 == "binomial") fam1 <- "bernoulli" # gbm::gbm doesn't like binomial even though it's the same
if (fam2 == "binomial") fam2 <- "bernoulli"
# tibble's don't collapse into a vector, instead an X x 1 df, which breaks various functionality.
if ("tbl" %in% class(grids)) grids <- as.data.frame(grids)
if ("tbl" %in% class(samples)) samples <- as.data.frame(samples)
# create basemap using gbm.basemap & these bounds, else basemap will be called for every map
if (!is.null(grids)) if (map) { # create basemap grids not null, map requested, basemap not provided
if (is.null(shape)) {
if (!exists("gbm.basemap")) {stop("you need to install gbm.basemap to run this function")}
bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
#create standard bounds from data, and extra bounds for map aesthetic
# xmid <- mean(bounds[1:2])
# ymid <- mean(bounds[3:4])
# xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
# xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
# yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
# yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
# extrabounds <- c(xextramin, xextramax, yextramin, yextramax) # identical code to what's in basemap
shape <- gbm.basemap(bounds = bounds,
savedir = savedir,
extrabounds = TRUE)
} # close isnull shape
} # close isnull grids
expvarnames <- names(samples[expvar]) # list of explanatory variable names
expvarcols <- cbind(cols[1:length(expvarnames)],expvarnames) # assign explanatory variables to colours
if (!is.null(offset)) {
if (is.character(offset)) offset <- which(colnames(samples) %in% offset) # if offset is the column name, change to column number
colnames(samples)[offset] <- "offset" # then change name to "offset"
}
if (is.list(tc)) { # if lists entered for tc lr or bf, split them to bin and gaus
if (length(tc) > 2) {stop("Only 2 tc list items allowed: 1 per family")}
tcgaus <- tc[[2]]
tc <- tc[[1]]
} else {tcgaus <- tc} # else make the gaus object the same as the bin. close if else
if (is.list(lr)) {
if (length(lr) > 2) {stop("Only 2 lr list items allowed: 1 per family")}
lrgaus <- lr[[2]]
lr <- lr[[1]]
} else {lrgaus <- lr} # close if else lr
if (is.list(bf)) {
if (length(bf) > 2) {stop("Only 2 bf list items allowed: 1 per family")}
bfgaus <- bf[[2]]
bf <- bf[[1]]
} else {bfgaus <- bf} # close if else bf
if (is.list(n.trees)) { # if list entered n.trees, split to fam1 and fam2
if (length(n.trees) > 2) {stop("Only 2 n.trees list items allowed: 1 per family")}
ntf1 <- n.trees[[1]]
ntf2 <- n.trees[[2]]
} else {
ntf1 <- n.trees
ntf2 <- n.trees} # else make fam1 and fam2 the same. close if else n.trees
resvar
i <- resvar
dir.create(names(samples[i])) # create resvar-named directory for outputs
m = 1 # Gaus only loop counter to allow best gaus BRT choice
n = 1 # Print counter for all loops of BRT combos & best bin BRT choice
if (!is.null(grids)) if (!all(expvarnames %in% names(grids))) stop(print("Expvar column names in samples but missing from grids:"), print(expvarnames[which(!expvarnames %in% names(grids))]))
if (anyNA(samples[i])) stop("Response variable range contains NA values, please filter out these rows with: mysamples <- mysamples[-which(is.na(mysamples[resvar])),]")
####2. ZI check & log####
# if user has asked code to check for ZI, check it & set new ZI status
if (ZI == "CHECK") if (sum(samples[,i] == 0, na.rm = TRUE) / length(samples[,i]) >= 0.5) ZI = TRUE else ZI = FALSE
# ensure resvar has zeroes (expects mix of successful & unsuccessful samples for bernoulli/binary runs)
if (!ZI) if (min(samples[i]) > 0) print("No zeroes in response variable. If using a zero inflated model, Method expects unsuccessful, as well as successful, samples")
# create binary (0/1) response variable, for bernoulli BRTs
samples$brv <- ifelse(samples[i] > 0, 1, 0)
brvcol <- which(colnames(samples) == "brv") # brv column number for BRT
# create logged response variable, for Gaussian BRTs when data are zero-inflated (otherwise just use resvar directly)
logem <- log1p(samples[,i]) # logs resvar i.e. containing zeroes
dont  <- samples[,i]
# log1p resvar if bin only (fam1 bin, fam2 FALSE), OR if resvar is delta & ZI & NOT poisson (which can't be logged, must be positive integers)
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI & (fam2 != "poisson")))) {samples$grv <- logem} else {samples$grv <- dont}
grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
if (ZI) {
grv_yes <- subset(samples, grv > 0) # nonzero subset for gaussian/poisson BRTs if zero inflated
} else {
grv_yes <- samples # use the full dataset if not ZI
}
ZI
is.null(loadgbm)
####3. Begin Report####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) { # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 14
# if only 1 permutation, = 19
} else { # else zi
reportcolno = 3 + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 7
# if only 1 permutation = 11
} # close if else ZI
if (!gaus) reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + 7
# 14: best bin brt, best gaus brt,
# Bin_BRT_simp predictors kept (ordered), Bin_BRT_simp predictors dropped,
# Gaus_BRT_simp predictors kept (ordered),Gaus_BRT_simp predictors dropped,
# Simplified Binary BRT stats, Simplified Gaussian BRT stats,
# Best Binary BRT variables, Relative Influence (Bin),
# Best Gaussian BRT variables, Relative Influence (Gaus),
# Biggest Interactions (Bin), Biggest Interactions (Gaus)
# + 5 elements for each loop: parameter combo n (tc lr & bf values),
# Bin BRT n stats, Bin BRT n name
# Gaus BRT n stats, Gaus BRT n name
Report <- data.frame(matrix(NA, nrow = (max(6,length(expvar))), ncol = (reportcolno)))
# build blank df, rows=biggest of 6 (max static row number of stats) or n of exp. vars
colnames(Report) <- c("Explanatory Variables","Response Variables","Zero Inflated?") # populate static colnames 1:3
# name bin columns if ZI
if (!gaus) {colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")
} else {
# do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {colnames(Report)[(reportcolno - 13):(reportcolno - 7)] <- c("Best Binary BRT",
"Bin_BRT_simp predictors dropped",
"Bin_BRT_simp predictors kept",
"Simplified Binary BRT stats",
"Best Binary BRT variables",
"Relative Influence (Bin)",
"Biggest Interactions (Bin)")}
colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Gaussian BRT",
"Gaus_BRT_simp predictors dropped",
"Gaus_BRT_simp predictors kept",
"Simplified Gaussian BRT stats",
"Best Gaussian BRT variables",
"Relative Influence (Gaus)",
"Biggest Interactions (Gaus)")} # close if else gaus
# populate the final 14 column names
Report[1:length(expvar),1] <- names(samples[expvar]) # put expvar names in first column
Report[1,2] <- names(samples[i]) # put resvar in col 2
Report[1,3] <- ZI # ZI in col 3
StatsObjectsList <- list()
Bin_Best_Score <- 0 # create blanks for best results to use in loops
Bin_Best_Model <- 0
Gaus_Best_Score <- 0
Gaus_Best_Model <- 0
fam1 == "bernoulli" & (!gaus | (gaus & ZI))
gaus
tcgaus
j <- 5
lrgaus
bfgaus
l <- 0.01
k <- 0.01
l <- 0.6
####7. Gaussian BRT####
print(paste0("Running ", fam2, " BRT, tc=",j,", lr=",k,", bf=",l))
write.csv(x = grv_yes[,grvcol], file = paste0("./",names(samples[i]),"/grv.csv"), row.names = FALSE)
assign(paste0("Gaus_BRT",".tc",j,".lr",k,".bf",l),
gbm.step.sd(data = grv_yes,
gbm.x = expvar,
gbm.y = grvcol,
family = fam2,
tree.complexity = j,
learning.rate = k,
bag.fraction = l,
n.trees = ntf2,
{if (!is.null(offset)) offset = grv_yes$offset},
) # ...
)
dev.print(file = paste0("./",names(samples[i]),"/pred_dev_gaus.jpeg"), device = jpeg, width = 600)
print(paste0("Done Gaus_BRT",".tc",j,".lr",k,".bf",l))
print(warnings())
print("Note: previous warnings may be reprinted")
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/")
library(tidyverse)
library(MASS)
library(vegan)
library(reshape)
library(doBy)
library(utils)
library(RcmdrMisc)
library(ResourceSelection)
library(boot)
library(ggplot2)
library(gplots)
library(rstatix)
library(dismo)
# library(ggBRT)
library(ape)
library(gbm)
library(gbm.auto)
#library(remotes)
#remotes::install_github("SimonDedman/gbm.auto", force = TRUE)
#import dataframe #
wide.df1 <- data.frame(read.csv("wide.df1.ch3.2022.11.csv", header = TRUE, as.is = TRUE)) # importing CSV#
wide.df1$geo <- as.factor(wide.df1$geo)
wide.df1$isl_grp <- as.factor(wide.df1$isl_grp)
wide.df1$archi <- as.factor(wide.df1$archi)
wide.df1$Season <- as.factor(wide.df1$Season)
wide.df1$bait_type <- as.factor(wide.df1$bait_type)
wide.df1$topo <- as.factor(wide.df1$topo)
wide.df1$log_vid_length <- log(wide.df1$vid_length)
gbm.auto(
grids = NULL,
samples = wide.df1,
expvar = c("ave_temp",
"ave_npp",
"depth",
"visibility",
"topo",
"grav",
"bait_type",
"time.no.bait",
"isl_grp",
"Season",
"lagoon.size"), # fix to final variables
# resvar = "nspp_elasmo", # works
resvar = "nspp_shark", #  nspp_ray
tc = c(5), # add combos you want to see for initial runs and it will try each. doesn't run the whole gambit like the loops do
lr = c(0.01),
bf = c(0.60),
ZI = FALSE,
fam1 = c("poisson"),
fam2 = c("poisson"), #
simp = FALSE, # Change to true
gridslat = 2,
gridslon = 1,
multiplot = TRUE,
cols = grey.colors(1, 1, 1),
linesfiles = TRUE, # change to true for final run
smooth = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2022-03_Frances_Naomi/2022-11-16 gbm.auto offset issue/",
savegbm = TRUE, # change to true for final runs
loadgbm = NULL,
varint = TRUE,
map = TRUE,
shape = NULL,
RSB = TRUE,
BnW = TRUE,
alerts = TRUE, # this is the noise alerts
# pngtype = c("quartz"), # quartz for mac  this one for windows : "cairo-png"
gaus = TRUE,
MLEvaluate = TRUE,
brv = NULL,
grv = NULL,
Bin_Preds = NULL,
Gaus_Preds = NULL,
offset = "log_vid_length"
)
library(devtools)
document()
