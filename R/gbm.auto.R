#' Automated Boosted Regression Tree modelling and mapping suite
#'
#' Automates delta log normal boosted regression trees abundance prediction.
#' Loops through all permutations of parameters provided (learning
#' rate, tree complexity, bag fraction), chooses the best, then simplifies it.
#' Generates line, dot and bar plots, and outputs these and the predictions
#' and a report of all variables used, statistics for tests, variable
#' interactions, predictors used and dropped, etc.. If selected, generates
#' predicted abundance maps, and Unrepresentativeness surfaces.
#'
#' @param grids Explantory data to predict to. Import with (e.g.) read.csv and
#' specify object name. Defaults to NULL (won't predict to grids)
#' @param samples Explanatory and response variables to predict from. Keep col
#' names short, no odd characters, starting numerals or terminal periods. Spaces
#'  may be converted to periods in directory names, underscores won't. Can be a
#'  subset
#' @param expvar List of column numbers of explanatory variables in 'samples',
#' expected e.g. c(1,35,67,etc.). No default
#' @param resvar Column number of response variable (e.g. CPUE) in samples.
#' Expected, e.g. 12. No default. Column name should be species name
#' @param tc Permutations of tree complexity allowed, can be vector with
#' the largest sized number no larger than the number of explanatory variables
#' e.g. c(2,7), or a list of 2 single numbers or vectors, the first to be passed
#' to the binary BRT, the second to the Gaussian, e.g. tc = list(c(2,6), 2) or
#' list(6, c(2,6))
#' @param lr Permutations of learning rate allowed. Can be a vector or a list of
#'  2 single numbers or vectors, the first to be passed to the binary BRT, the
#'  second to the Gaussian, e.g. lr = list(c(0.01,0.02),0.0001) or
#'  list(0.01,c(0.001, 0.0005))
#' @param bf Permutations of bag fraction allowed, can be single number, vector
#' or list, per tc and lr
#' @param ZI are data zero-inflated? TRUE FALSE "CHECK". TRUE: delta BRT,
#' log-normalised Gaus, reverse log-norm and bias corrected. FALSE: do Gaussian
#' only, no log-normalisation. CHECK: Tests data for you. Default is TRUE.
#' @param simp Try simplfying best BRTs?
#' @param gridslat Column number for latitude in 'grids'
#' @param gridslon Column number for longitude in 'grids'
#' @param cols Barplot colour vector. Assignment in order of explanatory
#' variables. Default 1*white: white bars black borders. '1*' repeats
#' @param linesfiles Save individual line plots' data as csv's?
#' @param savegbm Save gbm objects and make available in environment after
#' running? Open with load("Bin_Best_Model")
#' @param varint Calculate variable interactions? Default:TRUE, FALSE for error
#' "contrasts can be applied only to factors with 2 or more levels"
#' @param map Save abundance map png files?
#' @param mapshape Set coast shapefile, else downloaded and autogenerated
#' @param RSB Run Unrepresentativeness surface builder?
#' @param BnW Repeat maps in black and white e.g. for print journals
#' @param alerts Play sounds to mark progress steps
#' @param pngtype Filetype for png files, alternatively try "quartz"
#' @param ... Optional arguments for legend in legend.grid in gbm.map, and
#' gbm.step (dismo)
#'
#' @return Line, dot and bar plots, a report of all variables used, statistics
#' for tests, variable interactions, predictors used and dropped, etc. If
#' selected generates predicted abundance maps, and Unrepresentativeness surface
#'
#' @details Errors and their origins:
#'
#' 1. Error in FUN(X[[i]], ...) : only defined on a data frame with all numeric variables
#' > Explanatory variables are expected to be numeric
#'
#' 2. At bf=0.5, if nrows <= 42 gbm.step will crash
#' > Use gbm.bfcheck to determine optimal viable bf size
#'
#' 3. Maps/plots dont work/output
#' > If on a Mac, try changing pngtype to "quartz"
#'
#' 4. Error in while (delta.deviance > tolerance.test AMPERSAND n.fitted < max.trees)  :
#'  missing value where TRUE/FALSE needed
#' > Data are expected to contain zeroes (lots of them in zero-inflated cases),
#' have you already filtered them out?
#'
#' 5. Error in round(gbm.object$cv.statistics$deviance.mean, 4) : non-numeric
#' argument to mathematical function
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#'
#' 6. Error in if (n.trees > x$n.trees) { : argument is of length zero}
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#'
#' 7. Error in gbm.fit(x, y, offset = offset, distribution = distribution, w = w)
#' The dataset size is too small or subsampling rate is too large:
#' nTrain*bag.fraction <= n.minobsinnode
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#' It may be that you don't have enough positive samples to run BRT modelling
#' Run gbm.bfcheck to check recommended minimum BF size
#'
#' 8. Warning message: In cor(y_i, u_i) : the standard deviation is zero
#' > LR or BF probably too low in earlier BRT (normally Gaus run with highest TC)
#' It may be that you don't have enough positive samples to run BRT modelling
#' Run gbm.bfcheck to check recommended minimum BF size
#'
#' @examples gbm.auto(expvar = c(4:8, 10), resvar = 11, grids = mygrids,
#' tc = c(2,7), lr = c(0.005, 0.001), ZI = TRUE, savegbm = FALSE,
#' mapshape = coast)
#'
#' @author Simon Dedman, \email{simondedman@@gmail.com}
#'
#' @export
#' @import mapplots
#' @importFrom beepr beep
#' @importFrom labeling extended
#' @importFrom dismo gbm.interactions
#' @importFrom dismo gbm.plot.fits
#' @importFrom dismo gbm.plot
#' @importFrom dismo gbm.simplify
#' @importFrom dismo gbm.step
#' @importFrom gbm plot.gbm
#'
gbm.auto <- function(
  grids = NULL,         # explantory data to predict to. Import with (e.g.)
  # read.csv and specify object name. Defaults to NULL (won't predict to grids)
  samples,  # explanatory and response variables to predict from.
  # Keep col names short, no odd characters, starting numerals or terminal periods
  # Spaces may be converted to periods in directory names, underscores won't.
  # Can be a subset
  expvar,               # list of column numbers of explanatory variables in
  # 'samples', expected e.g. c(1,35,67,etc.). No default
  resvar,               # column number of response variable (e.g. CPUE) in
  # samples. Expected, e.g. 12. No default. Column name should be species name
  tc = c(2),            # permutations of tree complexity allowed, can be a
  # vector with the largest sized number no larger than the number of
  # explanatory variables e.g. c(2,7), or a list of 2 single numbers or vectors,
  # the first to be passed to the binary BRT, the second to the Gaussian, e.g.
  # tc = list(c(2,6), 2) or list(6, c(2,6))
  lr = c(0.01,0.005),   # permutations of learning rate allowed. Can be a
  # vector or a list of 2 single numbers or vectors, the first to be passed to
  # the binary BRT, the second to the Gaussian, e.g.
  # lr = list(c(0.01,0.02),0.0001) or list(0.01,c(0.001, 0.0005))
  bf = 0.5,             # permutations of bag fraction allowed, can be single
  # number, vector or list, per tc and lr
  ZI = "CHECK",         # are data zero-inflated? TRUE/FALSE/"CHECK".
  # TRUE: delta BRT, log-normalised Gaus, reverse log-norm and bias corrected.
  # FALSE: do Gaussian only, no log-normalisation.
  # CHECK: Tests data for you. Default is TRUE.
  simp = TRUE,          # try simplfying best BRTs?
  gridslat = 2,         # column number for latitude in 'grids'
  gridslon = 1,         # column number for longitude in 'grids'
  cols = grey.colors(1,1,1), # barplot colour vector. Assignment in order of
  # explanatory variables. Default 1*white: white bars black borders. '1*' repeats
  linesfiles = FALSE,   # save individual line plots' data as csv's?
  savegbm = TRUE,       # save gbm objects and make available in environment after running? Open with load("Bin_Best_Model")
  varint = TRUE,        # calculate variable interactions? Default:TRUE, FALSE
  # for error "contrasts can be applied only to factors with 2 or more levels"
  map = TRUE,           # save abundance map png files?
  mapshape = NULL,      # set coast shapefile, else downloaded and autogenerated
  RSB = TRUE,           # run Unrepresentativeness surface builder?
  BnW = TRUE,           # repeat maps in black and white e.g. for print journals
  alerts = TRUE,        # play sounds to mark progress steps
  pngtype = "cairo-png",# filetype for png files, alternatively try "quartz"
  ...)                  # optional arguments for gbm.map and gbm.step
{
  # Generalised Boosting Model / Boosted Regression Tree process chain automater.
  # Simon Dedman, 2012-6 simondedman@gmail.com github.com/SimonDedman/gbm.auto

  # Function to automate the many steps required to use boosted regression trees
  # to predict abundances in a delta process, i.e. binary (0/1) proportion
  # prediction coupled with presence-only abundance prediction to give total
  # prediction. Loops through all permutations of parameters provided (learning
  # rate, tree complexity, bag fraction), chooses the best, then tries to simplify
  # that. Generates line, dot and bar plots, and outputs these and the predictions
  # and a report of all variables used, statistics for tests, variable
  # interactions, predictors used and dropped, etc.. If selected, generates
  # predicted abundance maps, and Unrepresentativeness surfaces.
  #
  # Underlying functions are from packages gbm and dismo, functions from Elith
  # et al. 2008 (bundled as gbm.utils.R), mapplots, and my own functions gbm.map,
  # gbm.rsb, gbm.valuemap, gbm.cons, gbm.basemap

  ####1. Check packages, start loop####
  if (!require(gbm)) {stop("you need to install the gbm package to run this function")}
  if (!require(dismo)) {stop("you need to install the dismo package to run this function")}
  if (alerts) if (!require(beepr)) {stop("you need to install the beepr package to run this function")}
  if (!require(labeling)) {stop("you need to install the labeling package to run this function")}
  if (map) if (!require(mapplots)) {stop("you need to install the mapplots package to run this function")}
  if (map) if (!exists("gbm.map")) {stop("you need to install the gbm.map function to run this function")}
  if (RSB) if (!exists("gbm.rsb")) {stop("you need to install the gbm.rsb function to run this function")}
  if (RSB) if (!exists("gbm.map")) {stop("you need to install the gbm.map function to run this function")}
  if (!is.null(grids)) if (!exists("gbm.predict.grids")) {stop("you need to install the gbm.predict.grids function from gbm.utils.R to run this function")}
  if (!exists("roc")) {stop("you need to install the roc function from gbm.utils.R to run this function")}
  if (!exists("calibration")) {stop("you need to install the calibration function from gbm.utils.R to run this function")}
  require(gbm)
  require(dismo)
  if (alerts) require(beepr)
  require(labeling)

  if (!is.null(grids)) { # create basemap if not provided
    if (is.null(mapshape)) {
      if (!exists("gbm.basemap")) {stop("you need to install gbm.basemap to run this function")}
      bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
      #create standard bounds from data, and extra bounds for map aesthetic
      xmid <- mean(bounds[1:2])
      ymid <- mean(bounds[3:4])
      xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
      xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
      yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
      yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
      extrabounds <- c(xextramin, xextramax, yextramin, yextramax)
      shape <- gbm.basemap(bounds = extrabounds)
    } else {shape <- mapshape}}
  if (alerts) options(error = function() {beep(9)})  # give warning noise if it fails

  expvarnames <- names(samples[expvar]) # list of explanatory variable names
  expvarcols <- cbind(cols[1:length(expvarnames)],expvarnames) # assign explanatory variables to colours

  if (is.list(tc)) { # if lists entered for tc lr or bf, split them to bin and gaus
    if (length(tc) > 2) {stop("Only 2 tc list items allowed: 1 bin 1 Gaus")}
    tcgaus <- tc[[2]]
    tc <- tc[[1]]
  } else {tcgaus <- tc} # else make the gaus object the same as the bin

  if (is.list(lr)) {
    if (length(lr) > 2) {stop("Only 2 lr list items allowed: 1 bin 1 Gaus")}
    lrgaus <- lr[[2]]
    lr <- lr[[1]]
  } else {lrgaus <- lr}

  if (is.list(bf)) {
    if (length(bf) > 2) {stop("Only 2 bf list items allowed: 1 bin 1 Gaus")}
    bfgaus <- bf[[2]]
    bf <- bf[[1]]
  } else {bfgaus <- bf}

  for (i in resvar) {
    m = 1 # Gaus only loop counter to allow best gaus BRT choice
    n = 1   # Print counter for all loops of BRT combos & best bin BRT choice
    if (!is.null(grids)) if (!all(expvarnames %in% names(grids))) {stop("Not all expvar column names found as column names in grids")}

    ####2. ZI check & log####
    # if user has asked code to check for ZI, check it & set new ZI status
    if (ZI == "CHECK") if (sum(samples[,resvar] == 0,na.rm = TRUE)/length(samples[,resvar]) >= 0.5) ZI = TRUE else ZI = FALSE

    # ensure resvar has zeroes (expects mix of successful & unsuccessful samples)
    if (min(samples[i]) > 0) print("No zeroes in response variable. Method expects unsuccessful, as well as successful, samples")

    # create binary (0/1) response variable, for bernoulli BRTs
    samples$brv <- ifelse(samples[i] > 0, 1, 0)
    brvcol <- which(colnames(samples) == "brv") # brv column number for BRT

    # create logged response variable, for gaussian BRTs when data is zero-inflated (otherwise just use resvar directly)
    logem <- log(samples[,i])
    dont  <- samples[,i]
    if (ZI) {samples$grv <- logem} else {samples$grv <- dont}
    grvcol <- which(colnames(samples) == "grv") # grv column number for BRT
    grv_yes <- subset(samples, grv >= 0) # nonzero subset for gaussian BRTs
    # actually not nonzero but 'not -Inf' since zeroes logged to "-Inf"

    ####3. Begin Report####
    #reportcolno = (3 + (5*(length(tc)*length(lr)*length(bf))) + 14)
    if (ZI) {
      reportcolno = 3 + (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 14
    } else {
      reportcolno = 3 + (length(tcgaus)*length(lrgaus)*length(bfgaus)) + 7
    }

    # calculate number of columns for report:
      # 3: expvar names, resvar name, ZI state
      # 14: best bin brt, best gaus brt,
      # Bin_BRT_simp predictors kept (ordered), Bin_BRT_simp predictors dropped,
      # Gaus_BRT_simp predictors kept (ordered),Gaus_BRT_simp predictors dropped,
      # Simplified Binary BRT stats, Simplified Gaussian BRT stats,
      # Best Binary BRT variables, Relative Influence (Bin),
      # Best Gaussian BRT variables, Relative Influence (Gaus),
      # Biggest Interactions (Bin), Biggest Interactions (Gaus)
      # + 5 elements for each loop: parameter combo n (tc lr & bf values),
      # Bin BRT n stats, Bin BRT n name
      # Gaus BRT n stats, Gaus BRT n name
    ####Change per bin+gaus loop to 1 per bin or gaus loop: BRT name & stats.
    # remove "Parameter Combo n"
    Report <- data.frame(matrix(NA, nrow = (max(6,length(expvar))), ncol = (reportcolno)))
    # build blank df, rows=biggest of 6 (max static row number of stats) or n of exp. vars
    colnames(Report) <- c("Explanatory Variables","Response Variables","Zero Inflated?") # populate static colnames 1:3
    # name bin columns if ZI
    if (ZI) {colnames(Report)[(reportcolno - 13):(reportcolno - 7)] <- c("Best Binary BRT",
                                                                "Bin_BRT_simp predictors kept (ordered)",
                                                                "Bin_BRT_simp predictors dropped",
                                                                "Simplified Binary BRT stats",
                                                                "Best Binary BRT variables",
                                                                "Relative Influence (Bin)",
                                                                "Biggest Interactions (Bin)")}
    colnames(Report)[(reportcolno - 6):reportcolno] <- c("Best Gaussian BRT",
                                                         "Gaus_BRT_simp predictors kept (ordered)",
                                                         "Gaus_BRT_simp predictors dropped",
                                                         "Simplified Gaussian BRT stats",
                                                         "Best Gaussian BRT variables",
                                                         "Relative Influence (Gaus)",
                                                         "Biggest Interactions (Gaus)")
    # populate the final 14 column names
    Report[1:length(expvar),1] <- names(samples[expvar]) # put expvar names in first column
    Report[1,2] <- names(samples[i]) # put resvar in col 2
    Report[1,3] <- ZI # ZI in col 3

    Bin_Best_Score <- 0 # create blanks for best results to use in loops
    Bin_Best_Model <- 0
    Gaus_Best_Score <- 0
    Gaus_Best_Model <- 0

    # Begin bin loops
    if (ZI) {  # don't do if ZI=FALSE
      for (j in tc) {   # list permutations of tree complexity allowed
        for (k in lr) {   # list permutations of learning rate allowed
          for (l in bf) {   # list permutations of bag fraction allowed

            ####4. Binomial BRT####
            assign(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""),
                   gbm.step(data = samples,
                            gbm.x = expvar,
                            gbm.y = brvcol,
                            family = "bernoulli",
                            tree.complexity = j,
                            learning.rate = k,
                            bag.fraction = l,
                            ...)
            )

            ####5. Select best bin model####
            if (n == 1)
            {Bin_Best_Score <- get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
            Bin_Best_Model <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")
            }  else if (get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]] > Bin_Best_Score)
            {Bin_Best_Score <- get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
            Bin_Best_Model <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

            ####6. Add BRT bin stats to report####
            #### Don't do Parameter Combo n stats
            # Report[1:3,((m*5) - 1)] <- c(paste("tree complexity: ",j, sep = ""),
            #                              paste("learning rate: ",k, sep = ""),
            #                              paste("bag fraction: ",l, sep = ""))
            # don't do if ZI=FALSE. bin BRT stats
            if (ZI) {Report[1:6,(3 + n)] <- c(paste("trees: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                              paste("Training Data Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                              paste("CV Mean Deviance: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                              paste("CV Deviance SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                              paste("CV Mean Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                              paste("CV Correlation SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
            # bin BRT name
            colnames(Report)[3 + n] <- paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

            if (alerts) beep(2) # progress printer, right aligned
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)), "     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
            n <- n + 1   # Add to print counter
          } # close bf
        } # close lr
      } # close tc
    } # close ZI option, making all bin BRT objects & continuing through model selection

    # Begin Gaus loops
    for (j in tcgaus) {   # list permutations of tree complexity allowed
      for (k in lrgaus) {   # list permutations of learning rate allowed
        for (l in bfgaus) {   # list permutations of bag fraction allowed
          ####7. Gaussian BRT####
          assign(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""),
                 gbm.step(data = grv_yes,
                          gbm.x = expvar,
                          gbm.y = grvcol,
                          family = "gaussian",
                          tree.complexity = j,
                          learning.rate = k,
                          bag.fraction = l,
                          ...)
          )

          ####9. Select best Gaus model####
          if (m == 1)
            # problem. m won't equal 1 for gaus. WAIT. M will, N won't. Use N for everything except this one line?
          {Gaus_Best_Score <- get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
          Gaus_Best_Model <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")
          } else if (get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]] > Gaus_Best_Score)
          {Gaus_Best_Score <- get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]]
          Gaus_Best_Model <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")}

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Completed BRT ",n," of ", (length(tc)*length(lr)*length(bf)) + (length(tcgaus)*length(lrgaus)*length(bfgaus)),"     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          ####10. Add BRT bin stats to report####
          Report[1:6,(3 + n)] <- c(paste("trees: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                   paste("Training Data Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                   paste("CV Mean Deviance: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                   paste("CV Deviance SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                   paste("CV Mean Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                   paste("CV Correlation SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
          # Gaus BRT name
          colnames(Report)[3 + n] <- paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = "")

          n <- n + 1 # Add to print/loop counter for every bin or gaus BRT loop
          m <- m + 1 # Add to loop counter for Gaus best model selection

        } # close bfgaus
      } # close lrgaus
    } # close tcgaus, making all Gaus BRT objects & continuing through model selection

    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        Closed Loops         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####11. Test simplification benefit, do so if better####
    # if simp TRUE & ZI=TRUE, run simplification test on best bin model
    if (simp) {if (ZI) {Bin_Best_Simp_Check <- gbm.simplify(get(Bin_Best_Model))

    # if best number of variables to remove isn't 0 (i.e. it's worth simplifying),
    # re-run best model (Bin_Best_Model, using gbm.call to get its values) with
    # just-calculated best number of variables to remove, removed. gbm.x asks which
    # number of drops has the minimum mean (lowest point on the line) & that calls
    # up the list of predictor variables with those removed, from $pred.list
      if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0)
      assign("Bin_Best_Simp", gbm.step(data = samples,
                                       gbm.x = Bin_Best_Simp_Check$pred.list[[which.min(Bin_Best_Simp_Check$deviance.summary$mean)]],
                                       gbm.y = get(Bin_Best_Model)$gbm.call$gbm.y,
                                       tree.complexity = get(Bin_Best_Model)$gbm.call$tree.complexity,
                                       learning.rate = get(Bin_Best_Model)$gbm.call$learning.rate,
                                       family = get(Bin_Best_Model)$gbm.call$family,
                                       bag.fraction = get(Bin_Best_Model)$gbm.call$bag.fraction))

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Bin model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
    } # close ZI

      # Same for Gaus
      Gaus_Best_Simp_Check <- gbm.simplify(get(Gaus_Best_Model))
      if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0)
        assign("Gaus_Best_Simp", gbm.step(data = grv_yes,
                                          gbm.x = Gaus_Best_Simp_Check$pred.list[[which.min(Gaus_Best_Simp_Check$deviance.summary$mean)]],
                                          gbm.y = get(Gaus_Best_Model)$gbm.call$gbm.y,
                                          tree.complexity = get(Gaus_Best_Model)$gbm.call$tree.complexity,
                                          learning.rate = get(Gaus_Best_Model)$gbm.call$learning.rate,
                                          family = get(Gaus_Best_Model)$gbm.call$family,
                                          bag.fraction = get(Gaus_Best_Model)$gbm.call$bag.fraction))

      if (alerts) beep(2)
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Simplified Gaus model    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

      ## Select final best models
      if (ZI) {  # don't do if ZI=FALSE. If Bin_Best has a simplified model:
        if (min(Bin_Best_Simp_Check$deviance.summary$mean) < 0)
          # & if the simplified model has better correlation than Bin_Best itself
          if (Bin_Best_Simp$self.statistics$correlation > Bin_Best_Score[1])
            # then replace Bin_Best score/model values with those from the simplified model
          {Bin_Best_Score <- Bin_Best_Simp$self.statistics$correlation
          Bin_Best_Model <- "Bin_Best_Simp"}} # close ZI

      # Same for Gaus:
      if (min(Gaus_Best_Simp_Check$deviance.summary$mean) < 0)
        if (Gaus_Best_Simp$self.statistics$correlation > Gaus_Best_Score[1])
        {Gaus_Best_Score <- Gaus_Best_Simp$self.statistics$correlation
        Gaus_Best_Model <- "Gaus_Best_Simp"}
    } # close simp optional

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Best models selected     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####12. Line plots####
    dir.create(names(samples[i])) # create resvar-named directory for outputs

    # All plots on one image for Bin & Gaus
    if (ZI) {  # don't do if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Best_line.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
      gbm.plot(get(Bin_Best_Model),
               n.plots = length(get(Bin_Best_Model)$contributions$var),
               write.title = F, y.label = "Marginal Effect",
               plot.layout = c(ceiling(sqrt(length(get(Bin_Best_Model)$contributions$var))),
                               ifelse(sqrt(length(get(Bin_Best_Model)$contributions$var))
                                      - floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) < 0.5,
                                      floor(sqrt(length(get(Bin_Best_Model)$contributions$var))),
                                      floor(sqrt(length(get(Bin_Best_Model)$contributions$var))) + 1)))
      dev.off()} # close ZI

    png(filename = paste("./",names(samples[i]),"/Gaus_Best_line.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
    gbm.plot(get(Gaus_Best_Model),
             n.plots = length(get(Gaus_Best_Model)$contributions$var),
             write.title = F, y.label = "Marginal Effect",
             plot.layout = c(ceiling(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
                             ifelse(sqrt(length(get(Gaus_Best_Model)$contributions$var))
                                    - floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) < 0.5,
                                    floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))),
                                    floor(sqrt(length(get(Gaus_Best_Model)$contributions$var))) + 1)))
    dev.off()

    # All plots individually, named by explanatory variable, bin & gaus
    if (ZI) {  # don't do if ZI=FALSE
      for (o in 1:length(get(Bin_Best_Model)$contributions$var)) {
        png(filename = paste("./",names(samples[i]),"/Bin_Best_line_",as.character(get(Bin_Best_Model)$contributions$var[o]),".png", sep = ""),
            width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
        par(mar = c(1.35,3.4,0.4,0.5), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(2,0.5,0), xpd = NA)
        # bg=expvarcols[match(get(Bin_Best_Model)$contributions$var[o],expvarcols[,2]),1]) #changed margin to hide label #XPD YPD ALLOWS AXES TO EXTEND FURTHER TO ENCOMPASS ALL DATA? #colour removed
        plotgrid <- plot.gbm(get(Bin_Best_Model), match(get(Bin_Best_Model)$contributions$var[o], get(Bin_Best_Model)$gbm.call$predictor.names), lwd = 8, return.grid = TRUE)
        if (linesfiles) write.csv(plotgrid, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Bin_Best_line_", as.character(get(Bin_Best_Model)$contributions$var[o]), ".csv", sep = ""))
        xx <- extended(min(plotgrid[1]), max(plotgrid[1]),7, only.loose = TRUE) # sets range & ticks
        yy <- extended(min(plotgrid[2]), max(plotgrid[2]),7, only.loose = TRUE) # sets range & ticks
        plot(range(xx), range(yy), t = "n", xaxt = "n", yaxt = "n", bty = "n", ylab = NA)
        lines(plotgrid, type = "l")
        axis(1, lwd.ticks = 8, lwd = 8, at = xx) # is providing only the thick line & downticks
        axis(2, lwd.ticks = 8, lwd = 8, at = yy)
        #rug(quantile(samples[as.character(get(Bin_Best_Model)$contributions$var[o])], probs=seq(0,1,0.01), na.rm=TRUE), side=1, lwd=5, ticksize=0.03) #n of ticks probs seq arg 3: 0.1, 0.05, 0.01
        rug(samples[as.character(get(Bin_Best_Model)$contributions$var[o])][,1], side = 1, lwd = 5, ticksize = 0.03) # all points rug
        dev.off() }} # close ZI option

    for (p in 1:length(get(Gaus_Best_Model)$contributions$var)) {
      png(filename = paste("./",names(samples[i]),"/Gaus_Best_line_",as.character(get(Gaus_Best_Model)$contributions$var[p]),".png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 80, bg = "white", res = NA, family = "", type = pngtype)
      par(mar = c(1.35,3.4,0.4,0.5), fig = c(0,1,0,1), las = 1, lwd = 8, bty = "n", mgp = c(2,0.5,0), xpd = NA)
      plotgrid <- plot.gbm(get(Gaus_Best_Model),match(get(Gaus_Best_Model)$contributions$var[p], get(Gaus_Best_Model)$gbm.call$predictor.names), lwd = 8, return.grid = TRUE)
      if (linesfiles) write.csv(plotgrid, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Gaus_Best_line_", as.character(get(Gaus_Best_Model)$contributions$var[p]), ".csv", sep = ""))
      xx <- extended(min(plotgrid[1]), max(plotgrid[1]),7, only.loose = TRUE)
      yy <- extended(min(plotgrid[2]), max(plotgrid[2]),7, only.loose = TRUE)
      plot(range(xx),range(yy), t = "n", xaxt = "n", yaxt = "n", bty = "n", ylab = NA)
      lines(plotgrid, type = "l")
      axis(1, lwd.ticks = 8, lwd = 8, at = xx)
      axis(2, lwd.ticks = 8, lwd = 8, at = yy)
      rug(samples[as.character(get(Gaus_Best_Model)$contributions$var[p])][,1], side = 1, lwd = 5, ticksize = 0.03, quiet = TRUE)
      # quiet=TRUE because x axis is incorrect relative to points. Have tried only.loose=FALSE in xx line
      # also plotgridbin from bin to use bin's x axis but didn't work. Tried matching gaus & bin no joy.
      dev.off() }

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Line plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####13. Dot plots####
    if (ZI) {  # don't do if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Best_dot.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
      gbm.plot.fits(get(Bin_Best_Model))
      dev.off()} # close ZI

    png(filename = paste("./",names(samples[i]),"/Gaus_Best_dot.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "", type = pngtype)
    gbm.plot.fits(get(Gaus_Best_Model))
    dev.off()

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Dot plots created      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####14. 3D plot TODO####
    # gbm.perspec(Bin_Best,3,2, z.range=c(0,31), theta=340, phi=35,smooth="none",border="#00000025",col="#ff003310",shade = 0.95, ltheta = 80, lphi = 50)
    # gbm.perspec(Gaus_Best,3,2, z.range=c(0,31), theta=340, phi=35,smooth="none",border="#00000025",col="#ff003310",shade = 0.95, ltheta = 80, lphi = 50)

    ####15. Bar plots of variable influence####
    if (ZI) {  # create tables. Don't do if ZI=FALSE
      Bin_Bars <- summary(get(Bin_Best_Model),
                          cBars = length(get(Bin_Best_Model)$var.names),
                          n.trees = get(Bin_Best_Model)$n.trees,
                          plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
      write.csv(Bin_Bars, file = paste("./", names(samples[i]), "/Binary BRT Variable contributions.csv", sep = ""), row.names = FALSE)} # close ZI

    Gaus_Bars <- summary(get(Gaus_Best_Model),
                         cBars = length(get(Gaus_Best_Model)$var.names),
                         n.trees = get(Gaus_Best_Model)$n.trees,
                         plotit = FALSE, order = TRUE, normalize = TRUE, las = 1, main = NULL)
    write.csv(Gaus_Bars, file = paste("./", names(samples[i]), "/Gaussian BRT Variable contributions.csv", sep = ""), row.names = FALSE)

    if (alerts) beep(2)# progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Bar plot csvs created    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    if (ZI) {  # produce graphics. Don't do bin if ZI=FALSE
      png(filename = paste("./",names(samples[i]),"/Bin_Bars.png", sep = ""),
          width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
          type = pngtype)
      par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.8,mgp = c(1.5,0.5,0), cex = 1.3)
      midpoints <- barplot(rev(Bin_Bars[,2]), cex.lab = 1.2, las = 1, horiz = TRUE, cex.names = 0.8, xlab = "Influence %", col = rev(expvarcols[match(Bin_Bars[,1],expvarcols[,2]),1]), xlim = c(0,2.5 + ceiling(max(Bin_Bars[,2]))))
      text(0.1, midpoints, labels = rev(Bin_Bars[,1]), adj = 0, cex = 1.5)
      axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
      dev.off()} # close ZI

    png(filename = paste("./",names(samples[i]),"/Gaus_Bars.png", sep = ""),
        width = 4*480, height = 4*480, units = "px", pointsize = 4*12, bg = "white", res = NA, family = "",
        type = pngtype)
    par(mar = c(2.5,0.3,0,0.5), fig = c(0,1,0,1), cex.lab = 0.8,mgp = c(1.5,0.5,0), cex = 1.3)
    midpoints <- barplot(rev(Gaus_Bars[,2]), cex.lab = 1.2, las = 1, horiz = TRUE, cex.names = 0.8, xlab = "Influence %", col = rev(expvarcols[match(Gaus_Bars[,1],expvarcols[,2]),1]), xlim = c(0,2.5 + ceiling(max(Gaus_Bars[,2]))))
    text(0.1, midpoints, labels = rev(Gaus_Bars[,1]), adj = 0, cex = 1.5)
    axis(side = 1, lwd = 6, outer = TRUE, xpd = NA)
    dev.off()

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      Bar plots plotted      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####16. Variable interactions####
    # only do them if varint=TRUE, the default. Only do bin if ZI=TRUE
    if (ZI) if (varint) find.int_Bin <- gbm.interactions(get(Bin_Best_Model))
    if (varint) find.int_Gaus <- gbm.interactions(get(Gaus_Best_Model))
    if (alerts) beep(2) # progress printer, right aligned for visibility
    if (varint) {print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Variable interactions done XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

    #avoid sections 16-20 if not predicting to grids
    if (!is.null(grids)) {

      ####17. Binomial predictions####
      if (ZI) {  # don't do if ZI=FALSE
        gbm.predict.grids(get(Bin_Best_Model), grids, want.grids = F, sp.name = "Bin_Preds")
        grids$Bin_Preds <- Bin_Preds} # close ZI

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Binomial predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

      ####18. Gaussian predictions####
      gbm.predict.grids(get(Gaus_Best_Model), grids, want.grids = F, sp.name = "Gaus_Preds")
      if (ZI) {grids$Gaus_Preds <- Gaus_Preds

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Gaussian predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

      ####19. Backtransform logged Gaus to unlogged####
      grids$Gaus_Preds_Unlog <- exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)

      ####20. BIN*positive abundance = final abundance####
      grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds} else {grids$PredAbund <- Gaus_Preds} #if ZI=TRUE, unlog gaus & multiply by bin. Else just use gaus preds.
      predabund <- which(colnames(grids) == "PredAbund") # predicted abundance column number for writecsv

      if (alerts) beep(2) # progress printer, right aligned for visibility
      print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Final abundance calculated  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

      ####21. Final saves####
      # CSV of Predicted values at each site inc predictor variables' values.
      write.csv(grids, row.names = FALSE, file = paste("./", names(samples[i]), "/Abundance_Preds_All.csv", sep = ""))
      # CSV of Predicted values at each site without predictor variables' values.
      write.csv(grids[c(gridslat,gridslon,predabund)], row.names = FALSE, file = paste("./", names(samples[i]), "/Abundance_Preds_only.csv", sep = ""))
    } #close grids option from above section 16

    if (savegbm) { # Save model objects if switched on
      Bin_Best_Model_Object <- get(Bin_Best_Model)
      Bin_Best_Model <<- Bin_Best_Model_Object
      Gaus_Best_Model_Object <- get(Gaus_Best_Model)
      Gaus_Best_Model <<- Gaus_Best_Model_Object

      save(Gaus_Best_Model_Object,file = paste("./",names(samples[i]),"/Gaus_Best_Model", sep = ""))
      if (ZI) {save(Bin_Best_Model_Object,file = paste("./",names(samples[i]),"/Bin_Best_Model", sep = ""))}} #only save bin if ZI=TRUE

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Output CSVs written     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    ####22. Finalise & Write Report####
    if (ZI) { # only do bin bits if ZI
      Report[1:5,(reportcolno - 13)] <- c(paste("Model combo: ", Bin_Best_Model, sep = ""),
                                          paste("Model CV score: ", Bin_Best_Score, sep = ""),
                                          paste("Training data AUC score: ", get(Bin_Best_Model)$self.statistics$discrimination, sep = ""),
                                          paste("CV AUC score: ", get(Bin_Best_Model)$cv.statistics$discrimination.mean, sep = ""),
                                          paste("CV AUC se: ", get(Bin_Best_Model)$cv.statistics$discrimination.se, sep = ""))
      if (simp) {Report[1:dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 12)] <- as.character(subset(Bin_Best_Simp_Check$final.drops, order > 0)$preds)}
      if (simp) {Report[1:(length(Bin_Best_Simp_Check$final.drops$preds) - dim(subset(Bin_Best_Simp_Check$final.drops, order > 0))[1]),(reportcolno - 11)] <-
        as.character(Bin_Best_Simp_Check$final.drops$preds[((dim(subset(Bin_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Bin_Best_Simp_Check$final.drops$preds)])}
      Report[1:6,(reportcolno - 10)] <- c(paste("trees: ", get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                          paste("Training Data Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                          paste("CV Mean Deviance: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                          paste("CV Deviance SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                          paste("CV Mean Correlation: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                          paste("CV Correlation SE: ",get(paste("Bin_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
      Report[1:(length(Bin_Bars[,1])),(reportcolno - 9)] <- as.character(Bin_Bars$var)
      Report[1:(length(Bin_Bars[,2])),(reportcolno - 8)] <- as.character(Bin_Bars$rel.inf)
      # only do final variable interaction lines if varint=TRUE
      if (varint) Report[1:2,(reportcolno - 7)] <- c(paste(find.int_Bin$rank.list$var1.names[1]," and ",find.int_Bin$rank.list$var2.names[1],". Size: ",find.int_Bin$rank.list$int.size[1], sep = ""),
                                                     paste(find.int_Bin$rank.list$var1.names[2]," and ",find.int_Bin$rank.list$var2.names[2],". Size: ",find.int_Bin$rank.list$int.size[2], sep = ""))
    } # close ZI
    Report[1:2,(reportcolno - 6)] <- c(paste("Model combo: ", Gaus_Best_Model, sep = ""), paste("Model CV score: ", Gaus_Best_Score, sep = ""))
    if (simp) {Report[1:dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1], (reportcolno - 5)] <- as.character(subset(Gaus_Best_Simp_Check$final.drops ,order > 0)$preds)}
    if (simp) {Report[1:(length(Gaus_Best_Simp_Check$final.drops$preds) - dim(subset(Gaus_Best_Simp_Check$final.drops, order > 0))[1]), (reportcolno - 4)] <-
      as.character(Gaus_Best_Simp_Check$final.drops$preds[((dim(subset(Gaus_Best_Simp_Check$final.drops,order > 0))[1]) + 1):length(Gaus_Best_Simp_Check$final.drops$preds)])}
    Report[1:6,(reportcolno - 3)] <- c(paste("trees: ", get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$n.trees, sep = ""),
                                       paste("Training Data Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$self.statistics$correlation[[1]], sep = ""),
                                       paste("CV Mean Deviance: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.mean, sep = ""),
                                       paste("CV Deviance SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$deviance.se, sep = ""),
                                       paste("CV Mean Correlation: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.mean, sep = ""),
                                       paste("CV Correlation SE: ",get(paste("Gaus_BRT",".tc",j,".lr",k,".bf",l, sep = ""))$cv.statistics$correlation.se, sep = ""))
    Report[1:(length(Gaus_Bars[,1])),(reportcolno - 2)] <- as.character(Gaus_Bars$var)
    Report[1:(length(Gaus_Bars[,2])),(reportcolno - 1)] <- as.character(Gaus_Bars$rel.inf)
    # only do final variable interaction lines if varint=TRUE
    if (varint) Report[1:2,(reportcolno)] <- c(paste(find.int_Gaus$rank.list$var1.names[1]," and ",find.int_Gaus$rank.list$var2.names[1],". Size: ",find.int_Gaus$rank.list$int.size[1], sep = ""),
                                               paste(find.int_Gaus$rank.list$var1.names[2]," and ",find.int_Gaus$rank.list$var2.names[2],". Size: ",find.int_Gaus$rank.list$int.size[2], sep = ""))
    write.csv(Report, row.names = FALSE, na = "", file = paste("./", names(samples[i]), "/Report.csv", sep = ""))

    if (alerts) beep(2) # progress printer, right aligned for visibility
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Report CSV written      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

    if (!is.null(grids)) { #avoid sections 22&23 if not predicting to grids

      ####23. Unrepresentativeness surface builder####
      # builds doesn't plot surface. If built, plotted by map maker.
      if (RSB) {
        rsbdf_bin <- gbm.rsb(samples, grids, expvarnames, gridslat, gridslon)
        pos_samples <- subset(samples, brv > 0)
        rsbdf_gaus <- gbm.rsb(pos_samples, grids, expvarnames, gridslat, gridslon)
        rsbdf_both <- data.frame(rsbdf_bin, "Unrep_Gaus" = rsbdf_gaus[,"Unrepresentativeness"], "Unrep_Both" = (rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"]))
        write.csv(rsbdf_both, row.names = FALSE, file = paste("./", names(samples[i]), "/RSB.csv", sep = ""))
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       RSB CSV written       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))}

      ####24. Map maker####
      if (map == TRUE) {   # generate output image & set parameters
        png(filename = paste("./",names(samples[i]),"/PredAbundMap_",names(samples[i]),".png", sep = ""),
            width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
        par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
        # run gbm.map function with generated parameters
        gbm.map(x = grids[,gridslon],
                y = grids[,gridslat],
                z = grids[,predabund],
                species = names(samples[i]),
                shape = shape, #either autogenerated or set by user so never blank
                ...)  # allows gbm.auto's optional terms to be passed to subfunctions:
        # byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
        dev.off()

        if (alerts) beep(2) # progress printer, right aligned for visibility
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Reticulating splines     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
        print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Colour map generated     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

        if (BnW) { # if BnW=TRUE, run again in black & white for journal submission
          png(filename = paste("./",names(samples[i]),"/PredAbundMap_BnW_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = grids[,predabund],
                  species = names(samples[i]),
                  shape = shape, #either autogenerated or set by user so never blank
                  landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
                  mapback = "white",
                  heatcolours = grey.colors(8, start = 1, end = 0))
          dev.off()
          if (alerts) beep(2)  # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Black & white map generated XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
        } # close & save plotting device & close BnW optional

        if (RSB == TRUE) { # if RSB called, plot that surface separately
          png(filename = paste("./",names(samples[i]),"/RSB_Map_Bin_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon], # add Unrepresentativeness alpha surface
                  y = grids[,gridslat],
                  z = rsbdf_bin[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-1",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
          dev.off() #high value log breaks mean first ~5 values cluster near 0 for high
          # res there, but high values captures in the last few bins.

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Colour RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          png(filename = paste("./",names(samples[i]),"/RSB_Map_Gaus_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = rsbdf_gaus[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-1",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
          dev.off()

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          png(filename = paste("./",names(samples[i]),"/RSB_Map_Both_",names(samples[i]),".png", sep = ""),
              width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
          par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
          gbm.map(x = grids[,gridslon],
                  y = grids[,gridslat],
                  z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
                  mapmain = "Unrepresentativeness: ",
                  species = names(samples[i]),
                  legendtitle = "UnRep 0-2",
                  shape = shape, #either autogenerated or set by user so never blank
                  breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/1000)
          dev.off()

          if (alerts) beep(2) # progress printer, right aligned for visibility
          print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

          if (BnW) {     # if BnW=TRUE, do again for b&w
            png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Bin_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_bin[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0), #default 8 greys
                    ####BUG:setting heatcolours & colournumber overrides this####
                    landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
                    legendtitle = "UnRep 0-1",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
            dev.off()

            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     B&W RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

            png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Gaus_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_gaus[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0),
                    landcol = grey.colors(1, start = 0.8, end = 0.8),
                    legendtitle = "UnRep 0-1",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/2000)
            dev.off()

            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))

            png(filename = paste("./",names(samples[i]),"/RSB_Map_BnW_Both_",names(samples[i]),".png", sep = ""),
                width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
            par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0),xpd = FALSE)
            gbm.map(x = grids[,gridslon],
                    y = grids[,gridslat],
                    z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
                    mapmain = "Unrepresentativeness: ",
                    mapback = "white",
                    species = names(samples[i]),
                    heatcolours = grey.colors(8, start = 1, end = 0),
                    landcol = grey.colors(1, start = 0.8, end = 0.8),
                    legendtitle = "UnRep 0-2",
                    shape = shape, #either autogenerated or set by user so never blank
                    breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = FALSE))/1000)
            dev.off()
            if (alerts) beep(2) # progress printer, right aligned for visibility
            print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
          } # close BnW RSBs
        } # close RSB mapper
      } # close Map Maker
    } #close grids option from above section 22
    print(paste("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Grids/maps/everything done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", sep = ""))
  } # close response variable (resvar) loop
  if (alerts) beep(8)} # final user notification, then close the function
####END####
