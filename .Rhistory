#   # t: vector of thresholds used to compute confusion matrices
#   MLEval[18,] <- c("Threshold",
#                    "Threshold which produced best combo of TPR & TNR",
#                    e@t[which.max(e@TPR + e@TNR)])
#   # e@prevalence: Prevalence
#   MLEval[19,] <- c("Prevalence",
#                    "Prevalence",
#                    e@prevalence[which.max(e@TPR + e@TNR)])
#   # e@ODP: Overall diagnostic power
#   MLEval[20,] <- c("ODP",
#                    "Overall diagnostic power",
#                    e@ODP[which.max(e@TPR + e@TNR)])
#   # e@CCR: Correct classification rate
#   MLEval[21,] <- c("CCR",
#                    "Correct classification rate",
#                    e@CCR[which.max(e@TPR + e@TNR)])
#   # e@TPR: True positive rate
#   MLEval[22,] <- c("TPR",
#                    "True positive rate",
#                    e@TPR[which.max(e@TPR + e@TNR)])
#   # e@TNR: True negative rate
#   MLEval[23,] <- c("TNR",
#                    "True negative rate",
#                    e@TNR[which.max(e@TPR + e@TNR)])
#   # e@FPR: False positive rate
#   MLEval[24,] <- c("FPR",
#                    "False positive rate",
#                    e@FPR[which.max(e@TPR + e@TNR)])
#   # e@FNR: False negative rate
#   MLEval[25,] <- c("FNR",
#                    "False negative rate",
#                    e@FNR[which.max(e@TPR + e@TNR)])
#   # e@PPP: Positive predictive power
#   MLEval[26,] <- c("PPP",
#                    "Positive predictive power",
#                    e@PPP[which.max(e@TPR + e@TNR)])
#   # e@NPP: Negative predictive power
#   MLEval[27,] <- c("NPP",
#                    "Negative predictive power",
#                    e@NPP[which.max(e@TPR + e@TNR)])
#   # e@MCR: Misclassification rate
#   MLEval[28,] <- c("MCR",
#                    "Misclassification rate",
#                    e@MCR[which.max(e@TPR + e@TNR)])
#   # e@OR: Odds-ratio
#   MLEval[29,] <- c("OR",
#                    "Odds-ratio",
#                    e@OR[which.max(e@TPR + e@TNR)])
#   # e@kappa: Cohen's kappa
#   MLEval[30,] <- c("kappa",
#                    "Cohen's kappa",
#                    e@kappa[which.max(e@TPR + e@TNR)])
#   # dev from calc.deviance from dismo
#   MLEval[31,] <- c("dev",
#                    "deviance from 2 vecs, obs & pred vals",
#                    dev)
#
#   # MLEval$Value <- round(MLEval$Value, digits = 5)
#   write.csv(MLEval, row.names = FALSE, na = "", file = paste0("./", names(samples[i]), "/MLEvalMetricsGaus.csv"))
#
#   evalmetrics <- c("ROC", "kappa", "prevalence", "TPR", "TNR", "FPR", "FNR", "CCR", "PPP", "NPP", "MCR", "OR")
#   for (s in evalmetrics) {
#     png(filename = paste0("./",names(samples[i]),"/Gaus_Eval_", s, ".png"))
#     plot(e, s)
#     dev.off()
#   } # close for (s in evalmetrics)
# } # close if (gaus)
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Evaluation Metrics ProcessedXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if MLEvaluate
} # close loadgbm isnull
#avoid sections 19-25 if not predicting to grids
if (!is.null(grids)) {
# Load model objects if loadgbm set
if (!is.null(loadgbm)) {
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
load(paste0(loadgbm, "Bin_Best_Model"))
Bin_Best_Model <- "Bin_Best_Model_Object"
} # close ZI if
if (gaus) {
load(paste0(loadgbm, "Gaus_Best_Model"))
Gaus_Best_Model <- "Gaus_Best_Model_Object"
} # close gaus if
dir.create(names(samples[i])) # create resvar-named directory for outputs
} # close if isnull loadgbm
####19. Binomial predictions####
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {  # do fam1 runs if it's bin only (fam1 bin, gaus (ie fam2) false), or if it's delta & ZI
grids$Bin_Preds <- predict.gbm(object = get(Bin_Best_Model),
newdata = grids,
n.trees = get(Bin_Best_Model)$gbm.call$best.trees,
type = "response")
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Binomial predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if ZI
####20. Gaussian predictions####
if (gaus) {
Gaus_Preds <- predict.gbm(object = get(Gaus_Best_Model),
newdata = grids,
n.trees = get(Gaus_Best_Model)$gbm.call$best.trees,
type = "response")
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Gaussian predictions done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
grids$Gaus_Preds <- Gaus_Preds
####21. Backtransform logged Gaus to unlogged####
grids$Gaus_Preds_Unlog <- expm1(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
# exp for log, expm1 for log1p, L395
####22. BIN*positive abundance = final abundance####
grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds
} else { # close gaus yes zi yes run gaus yes zi no
grids$PredAbund <- Gaus_Preds #if ZI=TRUE, unlog gaus & multiply by bin. Else just use gaus preds.
} # close ifelse zi
} else { # if not gaus
grids$PredAbund <- grids$Bin_Preds # if only doing Bin, preds are just bin preds
} # close ifelse gaus
predabund <- which(colnames(grids) == "PredAbund") # predicted abundance column number for writecsv
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Final abundance calculated  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####23. Final saves####
# CSV of Predicted values at each site inc predictor variables' values.
write.csv(grids, row.names = FALSE, file = paste0("./", names(samples[i]), "/Abundance_Preds_All.csv"))
# CSV of Predicted values at each site without predictor variables' values.
# coerce character gridslat/lon into numeric since predabund is given as numeric & you can't mix
if (is.character(gridslat)) gridslat <- which(colnames(samples) == gridslat)
if (is.character(gridslon)) gridslon <- which(colnames(samples) == gridslon)
write.csv(grids[c(gridslat,gridslon,predabund)], row.names = FALSE, file = paste0("./", names(samples[i]), "/Abundance_Preds_only.csv"))
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     Output CSVs written     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
####24. Unrepresentativeness surface builder####
# builds doesn't plot surface. If built, plotted by map maker.
if (RSB) {
rsbdf_bin <- gbm.rsb(samples, grids, expvarnames, gridslat, gridslon)
pos_samples <- subset(samples, brv > 0)
if (gaus) {
rsbdf_gaus <- gbm.rsb(pos_samples, grids, expvarnames, gridslat, gridslon)
rsbdf_both <- data.frame(rsbdf_bin, "Unrep_Gaus" = rsbdf_gaus[,"Unrepresentativeness"], "Unrep_Both" = (rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"]))
write.csv(rsbdf_both, row.names = FALSE, file = paste0("./", names(samples[i]), "/RSB.csv"))
} else { # not gaus
write.csv(rsbdf_bin, row.names = FALSE, file = paste0("./", names(samples[i]), "/RSB.csv")) # if not gaus
} # close if else gaus
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       RSB CSV written       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if RSB
####25. Map maker####
if (map) {   # generate output image & set parameters
png(filename = paste0("./",names(samples[i]),"/PredAbundMap_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
# run gbm.map function with generated parameters
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = grids[,predabund],
species = names(samples[i]),
shape = shape, #either autogenerated or set by user so never blank
...)  # allows gbm.auto's optional terms to be passed to subfunctions:
# byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Reticulating splines     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    Colour map generated     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
if (BnW) { # if BnW=TRUE, run again in black & white for journal submission
png(filename = paste0("./",names(samples[i]),"/PredAbundMap_BnW_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = grids[,predabund],
species = names(samples[i]),
shape = shape, #either autogenerated or set by user so never blank
landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
mapback = "white",
heatcolours = grey.colors(8, start = 1, end = 0),
...)  # allows gbm.auto's optional terms to be passed to subfunctions:
# byx, byy, mapmain, heatcol, mapback, landcol, lejback, legendloc, grdfun, zero, quantile, heatcolours, colournumber
dev.off()
if (alerts) beep(2)  # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Black & white map generated XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close & save plotting device & close BnW optional
if (RSB) { # if RSB called, plot that surface separately
linear01seq <- seq(from = 0, to = 1, length.out = 9) #linear sequence from 0:1, 9 bins
exp01seq <- expm1(4*linear01seq)/expm1(4) # exponentiate to change shape then scale back to 1
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Bin_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
# breaks = expm1(breaks.grid(log(2000), ncol = 8, zero = TRUE))/2000) #old failing breaks
breaks = exp01seq)
dev.off() #high value log breaks mean first ~5 values cluster near 0 for high
# res there, but high values captures in the last few bins.
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Colour RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close if zi bin
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Gaus_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus map
if (ZI & gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_Both_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
species = names(samples[i]),
legendtitle = "UnRep 0-2",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Colour RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close both map
if (BnW) {     # if BnW=TRUE, do again for b&w
if (fam1 == "bernoulli" & (!gaus | (gaus & ZI))) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Bin_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0), #default 8 greys
####BUG:setting heatcolours & colournumber overrides this####
landcol = grey.colors(1, start = 0.8, end = 0.8), #light grey. 0=black 1=white
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     B&W RSB bin map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close bin RSB
if (gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Gaus_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-1",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB Gaus map done    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus RSB
if (ZI & gaus) {
png(filename = paste0("./",names(samples[i]),"/RSB_Map_BnW_Both_",names(samples[i]),".png"),
width = 4*1920, height = 4*1920, units = "px", pointsize = 4*48, bg = "white", res = NA, family = "", type = pngtype)
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,gridslon],
y = grids[,gridslat],
z = rsbdf_bin[,"Unrepresentativeness"] + rsbdf_gaus[,"Unrepresentativeness"],
mapmain = "Unrepresentativeness: ",
mapback = "white",
species = names(samples[i]),
heatcolours = grey.colors(8, start = 1, end = 0),
landcol = grey.colors(1, start = 0.8, end = 0.8),
legendtitle = "UnRep 0-2",
shape = shape, #either autogenerated or set by user so never blank
breaks = exp01seq)
dev.off()
if (alerts) beep(2) # progress printer, right aligned for visibility
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    B&W RSB combo map done   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close gaus (&combo) B&W RSB
} # close BnW RSBs
} # close RSB mapper
} # close Map Maker
} #close !isnull grids option from above section 19
print(paste0("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Grids/maps/everything done  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"))
} # close for i in resvar response variable loop
gc() # Force R to release memory it is no longer using
options(error = NULL) # reset error options to default
if (alerts) beep(8)  # final user notification, then close the function
}
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/")
## ************************  VR2C Modeling **********************************************************************************
## Load data into R
# dat <-  read.csv("Wave_Glider_Range_Testing_Analyses_092721.csv") # 3542 observations
## Data includes up to 1300 km
dat_vr2c <- read.csv("Wave_Glider_Range_Test_Vr2c_Only_092721.csv") # 1719 observations
## Cut down dataframe to only what we need
keep.vars <- dat_vr2c[, c(
"Detection", "Distancem", "Depth", "Deployment", "Temperature",
"WaveHeight", "WindSpeed", "CurrentSpeed", "VehicleSpeed", "SI", "SPL"
)]
names(keep.vars)
## How many observations have data?
check_1 <- keep.vars[keep.vars$Detection == 1, ] # 425 should be enough for analysis
## Changing deployment number to a factor
keep.vars$Deployment <- as.factor(keep.vars$Deployment)
## Checking what the minimum bag fraction needs to be
gbm.bfcheck(samples = keep.vars, resvar = 1, ZI = TRUE)
## Main model run for VR2C
## For bag fraction (bf) don't want lower than 0.4 or higher than 0.7 (per convo. w/ Chuck Bangley)
## Can look at multiple bfs in one line of code bf = c(0.6, 0.7)
## Note: turn off alerts if multiple small BRTs as it can cause R to crash
## expvar is the covariates in the model (column numbers)
## Make sure any covariates that are missing data have NA instead of NaN
## `grids' can be omitted if the objective is not to predict abundance at new sites
## Note* must indicate where to save outputs using savedir, otherwise it will go in R Temp folder (find using tempdir())
## Note* if doing multiple runs it will write over the last run unless you rename it in the folder
## If want a smoothing line on marginal effects plots then smooth = TRUE (default is F)
rm(StatsObjectsList)
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/")
gbm.auto(
samples = keep.vars,
expvar = c(2:11),
resvar = 1,
alerts = FALSE,
grids = NULL,
lr = c(0.05),
bf = c(0.5),
simp = F,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/Outputs/Vr2c Runs/",
savegbm = TRUE,
smooth = F,
gaus = FALSE,
ZI = TRUE,
# grids = NULL,
tc = c(2),
n.trees = 50,
fam1 = "bernoulli",
fam2 = "gaussian",
gridslat = 2,         # column number for latitude in 'grids'
gridslon = 1,         # column number for longitude in 'grids'
multiplot = F,     # create matrix plot of all line files? Default true
cols = grey.colors(1,1,1), # bar-plot colour vector. Assignment in order of
linesfiles = F,    # save individual line plots' data as CSVs?
loadgbm = NULL,       # relative or absolute location of folder containing
varint = F,        # calculate variable interactions? Default:TRUE, FALSE
map = F,           # save abundance map png files?
shape = NULL,         # set coast shapefile, else bounds calculated by gbm.map
RSB = F,           # run Unrepresentativeness surface builder?
BnW = F,           # repeat maps in black and white e.g. for print journals
pngtype = "cairo-png",
MLEvaluate = TRUE,    # do machine learning evaluation metrics & plots? Default TRUE
brv = NULL, # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
grv = NULL, # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
Bin_Preds = NULL, # addresses devtools::check's no visible binding for global variable https://cran.r-project.org/web/packages/data.table/vignettes/datatable-importing.html#globals
Gaus_Preds = NULL
)
# StatsObjectsList2 <- load("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/Outputs/Vr2c Runs/Detection/StatsObjectsList")
# saveRDS(object = StatsObjectsList, file = paste0("./", names(samples[i]), "/StatsObjectsList.Rds"))
StatsObjectsList <- readRDS(file = paste0("./", names(samples[i]), "/StatsObjectsList.Rds"))
StatsObjectsList <- readRDS(file = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/Outputs/Vr2c Runs/Detection/StatsObjectsList.Rds")
# tmp <- unlist(StatsObjectsList)
# names(tmp)
StatsObjectsDf <- data.frame(StatsNames = names(unlist(StatsObjectsList)),
Values = unlist(StatsObjectsList),
row.names = NULL)
View(StatsObjectsDf)
tmp <- stringi::stri_split_fixed(str = StatsObjectsDf$StatsNames,
pattern = "_",
n = 2,
simplify = TRUE)
View(tmp)
tmp <- as.data.frame(stringi::stri_split_fixed(str = StatsObjectsDf$StatsNames,
pattern = "_",
n = 2,
simplify = TRUE))
View(tmp)
tmp <- as.data.frame(stringi::stri_split_fixed(str = StatsObjectsDf$StatsNames,
pattern = "__",
n = 2,
simplify = TRUE))
# tmp <- unlist(StatsObjectsList)
# names(tmp)
StatsObjectsDf <- data.frame(StatsNames = names(unlist(StatsObjectsList)),
Values = unlist(StatsObjectsList),
row.names = NULL)
StatsObjectsDf <- as.data.frame(stringi::stri_split_fixed(str = StatsObjectsDf$StatsNames,
pattern = "__",
n = 2,
simplify = TRUE))
colnames(StatsObjectsDf) <- c("Model", "Test_Statistic")
View(StatsObjectsList)
# tmp <- unlist(StatsObjectsList)
# names(tmp)
StatsObjectsDf <- data.frame(StatsNames = names(unlist(StatsObjectsList)),
Values = unlist(StatsObjectsList),
row.names = NULL)
StatsObjectsNames <- as.data.frame(stringi::stri_split_fixed(str = StatsObjectsDf$StatsNames,
pattern = "__",
n = 2,
simplify = TRUE))
View(StatsObjectsNames)
colnames(StatsObjectsNames) <- c("Model", "Test_Statistic")
tmp <- cbind(StatsObjectsNames, StatsObjectsDf[,"Values"])
View(tmp)
tmp <- data.frame(StatsObjectsNames, Values = StatsObjectsDf[,"Values"])
StatsObjects <- data.frame(StatsObjectsNames, Values = StatsObjectsDf[,"Values"])
View(StatsObjects)
loops = 10
1:loops
getwd()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/tmp")
getwd()
loops = 10
for (i in 1:loops) { # loop through all gbm.autos
dir.create(paste0("./", i))
setwd(paste0("./", i))
write.csv(x = data.frame(x = 1:10, y = 1:10),
file = "Report.csv",
row.names = FALSE)
setwd("../") # move back up to root folder
}
getwd()
file.exists("./1/Report.csv")
file.exists("./11/Report.csv")
runloops <- data.frame(loop = 1:loops,
run = as.logical(rep(NA, loops)))
View(runloops)
# test for presence of report.csvs
for (i in 1:loops) { # loop through all gbm.autos
runloops[i, "run"] <- file.exists("./", i, "/Report.csv")
}
1:loops
i
runloops[i, "run"]
file.exists("./", i, "/Report.csv")
file.exists(paste0("./", i, "/Report.csv"))
# test for presence of report.csvs
for (i in 1:loops) { # loop through all gbm.autos
runloops[i, "run"] <- file.exists(paste0("./", i, "/Report.csv"))
}
View(runloops)
runloops <- data.frame(loop = 1:loops,
run = as.logical(rep(NA, loops)))
# test for presence of report.csvs
for (i in 1:loops) { # loop through all gbm.autos
runloops[i, "run"] <- file.exists(paste0("./", i, "/Report.csv"))
}
runloops[which(runloops$run == FALSE), "loop"]
runloops <- data.frame(loop = 1:loops,
run = as.logical(rep(NA, loops)))
# test for presence of report.csvs
for (i in 1:loops) { # loop through all gbm.autos
runloops[i, "run"] <- file.exists(paste0("./", i, "/Report.csv"))
}
# only want to keep the false ones
runloops[which(runloops$run == FALSE), "loop"]
1:loops
runloops[which(runloops$run == FALSE), "loop"]
library(devtools)
build()
library(devtools)
document()
build()
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/")
## Load package (install from CRAN if you have not done so)
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
sessionInfo() # just checks to make sure using the most recent version of gbm.auto
## ************************  VR2C Modeling **********************************************************************************
## Load data into R
# dat <-  read.csv("Wave_Glider_Range_Testing_Analyses_092721.csv") # 3542 observations
## Data includes up to 1300 km
dat_vr2c <- read.csv("Wave_Glider_Range_Test_Vr2c_Only_092721.csv") # 1719 observations
## Cut down dataframe to only what we need
keep.vars <- dat_vr2c[, c(
"Detection", "Distancem", "Depth", "Deployment", "Temperature",
"WaveHeight", "WindSpeed", "CurrentSpeed", "VehicleSpeed", "SI", "SPL"
)]
names(keep.vars)
## How many observations have data?
check_1 <- keep.vars[keep.vars$Detection == 1, ] # 425 should be enough for analysis
## Changing deployment number to a factor
keep.vars$Deployment <- as.factor(keep.vars$Deployment)
## Checking what the minimum bag fraction needs to be
gbm.bfcheck(samples = keep.vars, resvar = 1, ZI = TRUE)
setwd("/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/")
gbm.auto(
samples = keep.vars,
expvar = c(2:11),
resvar = 1,
alerts = FALSE,
grids = NULL,
lr = c(0.01, 0.005),
bf = c(0.5, 0.7),
simp = TRUE,
savedir = "/home/simon/Documents/Si Work/PostDoc Work/Gbmauto help/2021-09 Bonnie Ahr waveglider/Wave_Glider_Range_Test_Vr2c_Only_092721/Outputs/Vr2c Runs/",
savegbm = TRUE,
smooth = TRUE,
gaus = FALSE,
ZI = TRUE
)
