# new data (new.dat) must be a data frame with column names identical to names for all variables in the model used for prediction.
# pred.vec is a vector of -9999's, the length of the scanned full grid (i.e. without nodata values excluded).
# filepath must specify the whole path as a character vector,but without the final file name - eg "c:/gbm/"
temp <- predict.gbm(model, new.dat, n.trees = model$gbm.call$best.trees, type = "response")
if (want.grids) {
newname <- paste0(filepath, sp.name,".asc")
full.pred <- pred.vec
full.pred[as.numeric(row.names(new.dat))] <- temp
if (header) {
write(paste0("ncols          ",num.col),newname)
write(paste0("nrows          ",num.row),newname,append = T)
write(paste0("xllcorner      ",xll),newname,append = T)
write(paste0("yllcorner      ",yll),newname,append = T)
write(paste0("cellsize       ",cell.size),newname,append = T)
write(paste0("NODATA_value ",no.data),newname,append = T)
}
if (full.grid) {
full.pred.mat <- matrix(full.pred, nrow = num.row, ncol = num.col, byrow = T)
if (plot) {image(z = t(full.pred.mat)[, nrow(full.pred.mat):1], zlim =  c(0,1), col = rev(topo.colors(12)))}
write.table(full.pred.mat, newname, sep = " ", append = T, row.names = F, col.names = F)
#also write to R directory, if required:
if (preds2R) {assign(sp.name, temp, pos = 1)}
} else {
full.pred.mat <- matrix(full.pred, nrow = part.row, ncol = num.col, byrow = T)
write.table(full.pred.mat, newname, sep = " ", append = T, row.names = F, col.names = F)
if (preds2R) {assign(paste0(sp.name, part.number), temp, pos = 1)}
}
} else {
assign(sp.name, temp, pos = 1)
}
gbm.predict.grids(get(Gaus_Best_Model), grids,
want.grids = F, sp.name = "Gaus_Preds")
Gaus_Preds <- gbm.predict.grids(model = get(Gaus_Best_Model),
new.dat = grids,
want.grids = F,
sp.name = "Gaus_Preds")
Gaus_Preds
grids$Gaus_Preds <- Gaus_Preds
exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
grids$Gaus_Preds_Unlog <- exp(Gaus_Preds + 1/2 * sd(get(Gaus_Best_Model)$residuals, na.rm = FALSE) ^ 2)
grids$PredAbund <- grids$Gaus_Preds_Unlog * grids$Bin_Preds
Bin_Preds
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
library(devtools)
install_github("SimonDedman/gbm.auto")
library(gbm.auto)
gbm.auto
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
gbm.auto
library(gbm.auto)
gbm.auto
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
data(grids)
data(samples)
setwd("/home/simon/Desktop/gbmauto/")
library(shapefiles)
coast <- read.shapefile("/home/simon/Desktop/gbmauto/CroppedMap/Crop_Map")
gbm.auto(grids = grids,
samples = samples,
expvar = c(4:8, 10),
resvar = 11,
tc = c(7),
lr = c(0.005),
ZI = TRUE,
savegbm = FALSE,
multiplot = F,
linesfiles = F,
varint = F,
shape = coast)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
check()
library(devtools)
check()
library(gbm.auto)
library(devtools)
check()
library(devtools)
check()
as.numeric(TRUE)
as.numeric(FALSE)
citatio(dismo)
citation(dismo)
citation("dismo")
citation("gbm")
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
data(grids)
data(samples)
expvar = c(4:8, 10)
resvar = 11
tc = c(2,7)
lr = c(0.005, 0.001)
ZI = TRUE
savegbm = FALSE
shape = NULL
bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
gridslat = 2
gridslon = 1
bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
#create standard bounds from data, and extra bounds for map aesthetic
xmid <- mean(bounds[1:2])
ymid <- mean(bounds[3:4])
xextramax <- ((bounds[2] - xmid) * 1.6) + xmid
xextramin <- xmid - ((xmid - bounds[1]) * 1.6)
yextramax <- ((bounds[4] - ymid) * 1.6) + ymid
yextramin <- ymid - ((ymid - bounds[3]) * 1.6)
extrabounds <- c(xextramin, xextramax, yextramin, yextramax)
bounds = extrabounds
getwd()
setwd("/home/simon/Desktop/gbmauto/")
#   require(rgeos) # subfunctions for rgdal & others
# if (!require(raster)) install.packages("raster")
#   require(raster) # for crop
# if (!require(maptools)) install.packages("maptools")
#   require(maptools) # for WriteSpatialShape
# if (!require(shapefiles)) install.packages("shapefiles")
#   require(shapefiles) # for read.shapefile
# if (!require(sf)) install.packages("sf")
#   require(sf) # for everything after sf/st update, can remove the rest?
###improve these: check if installed, install if not else library####
startdir <- getwd() # record original directory
is.null(bounds)
xmin = bounds[1] #for sf/st upgrade
xmax = bounds[2]
ymin = bounds[3]
ymax = bounds[4]
res
res = "CALC"
zipvers = "2.3.7"
savename = "Crop_Map.shp"
if (res == 1) res <- "c" # If res provided as number convert to letter
if (res == 2) res <- "l"
if (res == 3) res <- "i"
if (res == 4) res <- "h"
if (res == 5) res <- "f"
if (res == "CALC") { # Calculate res based on size of bounds
scope <- max((bounds[2] - bounds[1]), (bounds[4] - bounds[3])) # distance of largest dimension, x or y
if (scope >= 160) res <- "c" # bigger diff = larger map = lower res
if (160 > scope & scope >= 70) res <- "l"
if (70 > scope & scope >= 29) res <- "i"
if (29 > scope & scope >= 9) res <- "h"
if (9 > scope) res <- "f"}
getzip
getzip = TRUE
ifelse(getzip == TRUE, {# download & unzip GSHGG if getzip = TRUE
download.file(paste0("https://www.ngdc.noaa.gov/mgg/shorelines/data/gshhg/latest/gshhg-shp-", zipvers, ".zip"), "GSHHG.zip")
unzip("GSHHG.zip")
setwd("./GSHHS_shp")}
, setwd(getzip)) # else just setwd to there
setwd(paste("./", res, sep = "")) #setwd to res subfolder
if (extrabounds) { # grow bounds extents if requested
#bounds = c(range(grids[,gridslon]),range(grids[,gridslat]))
xmid <- mean(bounds[1:2])
ymid <- mean(bounds[3:4])
xmax <- ((bounds[2] - xmid) * 1.6) + xmid #updated for sf/st
xmin <- xmid - ((xmid - bounds[1]) * 1.6)
ymax <- ((bounds[4] - ymid) * 1.6) + ymid
ymin <- ymid - ((ymid - bounds[3]) * 1.6)
#bounds <- c(xmin, xmax, ymin, ymax)
}
extrabounds
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
extrabounds = TRUE
if (extrabounds) { # grow bounds extents if requested
xmid <- mean(bounds[1:2])
ymid <- mean(bounds[3:4])
xmax <- ((bounds[2] - xmid) * 1.6) + xmid #updated for sf/st
xmin <- xmid - ((xmid - bounds[1]) * 1.6)
ymax <- ((bounds[4] - ymid) * 1.6) + ymid
ymin <- ymid - ((ymid - bounds[3]) * 1.6)
}
world1 <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
world2 <- st_read(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1"), quiet = TRUE) # read in worldmap
library(sf::st_read())
library(sf::st_read
)
library(sf)
world2 <- st_read(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1"), quiet = TRUE) # read in worldmap
class(world1)
class(world2)
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
check()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.auto.R')
library(gbm.auto)
data(samples)
gbm.bfcheck(samples = samples, resvar = "Cuckoo", ZI = F)
gbm.bfcheck(samples = samples, resvar = "Cuckoo")
data(grids)
png(...)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"])
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto/")
4*1920
4*48
png(filename = "tmp.png", width = 7680, height = 7680, units = "px",
pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"], species = "Effort")
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
install_github("SimonDedman/gbm.auto")
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.rsb.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
setwd("/home/simon/Desktop/gbmauto/")
data(grids)
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px",
pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"]
, species = "Effort")
dev.off()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"], species = "Effort")
# map
data(grids)
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"], species = "Effort")
dev.off()
x = grids[,"Longitude"]
y = grids[,"Latitude"]
z = grids[,"Effort"]
species = "Effort"
byx = NULL
byy = NULL
grdfun = mean
mapmain = "Predicted CPUE (numbers per hour): "
heatcolours = c("white", "yellow", "orange","red", "brown4")
colournumber = 8
shape = NULL
landcol = "grey80"
mapback = "lightblue"
legendloc = "bottomright"
legendtitle = "CPUE"
lejback = "white"
zero = TRUE
quantile = 1
byxout = FALSE
breaks = NULL
byxport = NULL
is.null(shape)
bounds = c(range(x),range(y))
extrabounds = TRUE
getzip = TRUE
zipvers = "2.3.7"
savename = "Crop_Map.shp"
res = "CALC"
startdir <- getwd()
is.null(bounds)
# if bounds is entered it's user below, else check grids & gridslat & gridslon
if (is.null(bounds)) {
#check none of grids & gridslat & gridslon is null, if any are print message
if (is.null(grids)) stop("if bounds is NULL grids needs to be specified")
if (is.null(gridslat)) stop("if bounds is NULL gridslat needs to be specified")
if (is.null(gridslon)) stop("if bounds is NULL gridslon needs to be specified")
#check they're all the correct format
if (!is.data.frame(grids)) stop("grids needs to be a data frame")
if (!is.numeric(gridslat)) stop("gridslat needs to be a number")
if (!is.numeric(gridslon)) stop("gridslon needs to be a number")
# construct bounds from gridslat & gridslon ranges in grids
bounds <- c(range(grids[,gridslon]), range(grids[,gridslat])) #still required later despite sf/st update
xmin = min(grids[,gridslon]) #for sf/st upgrade
xmax = max(grids[,gridslon])
ymin = min(grids[,gridslat])
ymax = max(grids[,gridslat])
} else {
xmin = bounds[1] #for sf/st upgrade
xmax = bounds[2]
ymin = bounds[3]
ymax = bounds[4]
}
if (res == 1) res <- "c" # If res provided as number convert to letter
if (res == 2) res <- "l"
if (res == 3) res <- "i"
if (res == 4) res <- "h"
if (res == 5) res <- "f"
if (res == "CALC") { # Calculate res based on size of bounds
scope <- max((bounds[2] - bounds[1]), (bounds[4] - bounds[3])) # distance of largest dimension, x or y
if (scope >= 160) res <- "c" # bigger diff = larger map = lower res
if (160 > scope & scope >= 70) res <- "l"
if (70 > scope & scope >= 29) res <- "i"
if (29 > scope & scope >= 9) res <- "h"
if (9 > scope) res <- "f"}
ifelse(getzip == TRUE, {# download & unzip GSHGG if getzip = TRUE
download.file(paste0("https://www.ngdc.noaa.gov/mgg/shorelines/data/gshhg/latest/gshhg-shp-", zipvers, ".zip"), "GSHHG.zip")
unzip("GSHHG.zip")
setwd("./GSHHS_shp")}
, setwd(getzip)) # else just setwd to there
setwd(paste("./", res, sep = "")) #setwd to res subfolder
if (extrabounds) { # grow bounds extents if requested
xmid <- mean(bounds[1:2])
ymid <- mean(bounds[3:4])
xmax <- ((bounds[2] - xmid) * 1.6) + xmid #updated for sf/st
xmin <- xmid - ((xmid - bounds[1]) * 1.6)
ymax <- ((bounds[4] - ymid) * 1.6) + ymid
ymin <- ymid - ((ymid - bounds[3]) * 1.6)
}
# world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
# read_sf results in a sf tibble which needs tibble installed. st_read is a sf dataframe. Changed also in @importFrom
world <- st_read(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1"), quiet = TRUE) # read in worldmap
cropshp <- st_crop(world, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax) # crop to extents
library(sf)
# world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
# read_sf results in a sf tibble which needs tibble installed. st_read is a sf dataframe. Changed also in @importFrom
world <- st_read(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1"), quiet = TRUE) # read in worldmap
cropshp <- st_crop(world, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax) # crop to extents
setwd(startdir)
dir.create("CroppedMap") # create conservation maps directory
setwd("CroppedMap")
st_write(cropshp, dsn = savename)
is.null(byx)
# if user hasn't entered byx or byy values, generate them from the data
if (is.null(byx)) {
# work out cell size for uniform square gridded data: Create blank vector for grid length calcs
bydist <- rep(NA, length(x))
# and attach it to grids
cells <- data.frame(LONGITUDE = x, bydist = bydist, stringsAsFactors = FALSE)
# fill it: if [next longitude minus current longitude] equals [current longitude minus previous longitude], that's a uniform cell.
# data rounded to prevent tiny fluctuations counting as differences. Need to set that tolerance.
# Could do 10% of average distance between uniform points, but you don't know that til the end!
cells[2:(length(x) - 1),"bydist"] <-
ifelse(round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1], digits = 5)
==
round(cells[3:length(x),1] - cells[2:(length(x) - 1),1], digits = 5),
round(cells[2:(length(x) - 1),1] - cells[1:(length(x) - 2),1], digits = 5),
NA)
# Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
byx <- mean(cells$bydist, na.rm = TRUE)
byy <- byx
if (byxout) byxport <<- byx
}
shape <- cropmap
shape <- cropshp
grd <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = grdfun)
library(mapplots)
grd <- make.grid(x, y, z, byx, byy, xlim = range(x), ylim = range(y), fun = grdfun)
# create gridded data. fun defaults to sum which is bad since accidentally
# overlapping points will look anomalous
heatcol = colorRampPalette(heatcolours)(colournumber)
# create heatcol from component parts
if (is.null(breaks)) breaks <- breaks.grid(grd, zero = zero, quantile = quantile, ncol = length(heatcol))
# if breaks specified, do nothing (used later in draw.grid) else generate them
if (zero) {heatcol = c("#00000000", colorRampPalette(heatcol)(length(heatcol) - 1))}
# if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.grid(grd, breaks, col = heatcol)
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = legendtitle, col = heatcol)
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
# if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.grid(grd, breaks, col = heatcol)
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = legendtitle, col = heatcol)
dev.off()
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
# if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
dev.off()
world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
setwd("/home/simon/Desktop/gbmauto/GSHHS_shp/f/")
world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
cropshp <- st_crop(world, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax) # crop to extents
setwd(startdir)
dir.create("CroppedMap") # create conservation maps directory
setwd("CroppedMap")
st_write(cropshp, dsn = savename)
dev.off()
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
shape <- cropshp
# if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.grid(grd, breaks, col = heatcol)
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
legend.grid(legendloc, breaks = breaks, type = 2, inset = 0, bg = lejback, title = legendtitle, col = heatcol)
dev.off()
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
draw.shape(shape = shape, col = landcol) # add coastline
draw.shape
getwd()
setwd("/home/simon/Desktop/gbmauto/GSHHS_shp/f/")
# world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
# read_sf results in a sf tibble which needs tibble installed. st_read is a sf dataframe. Changed also in @importFrom
world <- read.shapefile(paste0("GSHHS_", res, "_L1"))
library(shapefiles)
# world <- read_sf(dsn = paste0("GSHHS_", res, "_L1.shp"), layer = paste0("GSHHS_", res, "_L1")) # read in worldmap
# read_sf results in a sf tibble which needs tibble installed. st_read is a sf dataframe. Changed also in @importFrom
world <- read.shapefile(paste0("GSHHS_", res, "_L1"))
savename
savename = "Crop_Map"
cropshp <- read.shapefile(savename)
getwd()
setwd("/home/simon/Desktop/gbmauto/CroppedMap/")
cropshp <- read.shapefile(savename)
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
# if zero = TRUE add alpha as 1st colour (1st 2 breakpoints)
basemap(xlim = range(x), ylim = range(y), main = paste0(mapmain, species), bg = mapback, xlab = "Longitude", ylab = "Latitude")
shape <- cropshp
# plot grd data w/ breaks for colour breakpoints
draw.shape(shape = shape, col = landcol) # add coastline
dev.off()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.map.R')
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
# map
data(grids)
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"], species = "Effort")
dev.off()
traceback()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
document()
document9)
library(devtools)
document()
library(devtools)
install_github("SimonDedman/gbm.auto", force = T)
library(gbm.auto)
# map
data(grids)
setwd("/home/simon/Desktop/gbmauto/")
png(filename = "gbmmap.png", width = 7680, height = 7680, units = "px", pointsize = 192, bg = "white", res = NA, family = "", type = "cairo-png")
par(mar = c(3.2,3,1.3,0), las = 1, mgp = c(2.1,0.5,0), xpd = FALSE)
gbm.map(x = grids[,"Longitude"], y = grids[,"Latitude"], z = grids[,"Effort"], species = "Effort")
dev.off()
source('~/Dropbox/Galway/Analysis/R/gbm.auto/R/gbm.basemap.R')
document()
library(devtools)
build()
document()
